[{"title":"迭代器与生成器","url":"/blog/2019/05/03/Iterator&generator/","content":"\n## 一、迭代器规范\n\n**一个标准的遍历器需要拥有以下属性，并且通过查看 for-of 的转码能够知道这些属性都是怎么样被调用的。**\n\n``` js\nIterator [必须]\n\tnext() {method}: 取得下一个IteratorResult\nIterator [可选]\n\treturn() {method}: 停止迭代并返回IteratorResult\n\tthrow() {method}: 通知错误并返回IteratorResult\n\nIteratorResult\n\tvalue {property}: 当前的迭代值或最终的返回值\n\t\t（如果它的值为`undefined`，是可选的）\n\tdone {property}: 布尔值，指示完成的状态\n\n// for-of 转码\nfor (var _iterator = it[Symbol.iterator](), _step; (_step = _iterator.next()).done;) {\n    var a = _step.value;\n    console.log(a);\n}\n```\n\n**根据上面的规范，我们可以自己定义一个可迭代的对象，并用 for-of 来遍历它。**\n\n``` js\nlet obj = {\n    0: 0,\n    1: 1,\n    length: 2,\n    [Symbol.iterator] () {\n        let _obj = this, index = 0, length = _obj.length;\n\n        return {\n            [Symbol.iterator] () {return this},\n            next() {\n\t\t\t\treturn index < length ?\n                { value: `No.${index} is ${_obj[index++]}`, done: false }:\n                { value: 'undefined', done: true};\n\t\t\t},\n\n\t\t\treturn() {\n\t\t\t\tconsole.log(\n\t\t\t\t\t\"iterator return\"\n\t\t\t\t);\n\t\t\t\treturn { value: _obj[index], done: true };\n\t\t\t}\n        }\n    }\n}\n\nfor(let item of obj) {\n\tconsole.log(item);\n    break;\n}\n\n// No.0 is 0\n// iterator return\n\nconsole.log([...obj]);\n//  [\"No.0 is 0\", \"No.1 is 1\"]\n```\n\n## 二、Generator\n### Generator\n\n**Generator 函数可以在运行期间暂停它自己，还可以立即或者稍后继续运行，而且 Generator 函数生成的是一个迭代器，所以可以放入 for-of 中循环。**\n\n``` js\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nfor(let item of gen()) {\n    console.log(item);\n}\n// 1， 2， 3\n\nconsole.log([...gen()]);\n//  [1, 2, 3]\n```\n\n**这让在对象上添加迭代器变得简单。**\n\n``` js\nlet obj = {\n    0: 0,\n    1: 1,\n    length: 2,\n    *[Symbol.iterator] () {\n        let index = 0, length = this.length;\n\n        while(index < length) {\n            yield `No.${index} is ${this[index++]}`;\n        }\n    }\n}\n\nconsole.log([...obj]);\n//  [\"No.0 is 0\", \"No.1 is 1\"]\n```\n\n### yield *\n\n**一个 * 使 yield 成为一个机制非常不同的 yield *，称为 yield 委托。yield * ..需要一个可迭代对象；然后它调用这个可迭代对象的迭代器，并将它自己的宿主 generator 的控制权委托给那个迭代器，直到它被耗尽。**\n\n``` js\nfunction *foo() {\n\tyield *[1,2,3];\n}\n\n// 等同于\nfunction *foo() {\n\tyield 1;\n\tyield 2;\n\tyield 3;\n}\n```\n\n**如果 yield 委托的是一个 Generator 函数，且委托的 Generator 函数中有返回值，返回值会被前一个函数的 yield * 捕获。**\n``` js\nfunction *foo() {\n\tyield *[1,2,3];\n\treturn 4;\n}\n\nfunction *bar() {\n\tvar x = yield *foo();\n\tconsole.log( \"x:\", x );\n}\n\nfor (var v of bar()) {\n\tconsole.log( v );\n}\n\n// 1\n// 2\n// 3\n// x: 4\n```\n\n### 转译 Generator\n\n**以下为 babel 中比较系统得显示了 Generator 的转译，一个比较系统的遍历器。**\n\n``` js\n// 源代码\nfunction* bar() {\n    yield 1;\n    yield 2\n    yield 3\n    yield 4;\n}\n\n// babel 转义代码\nvar IteratorPrototype = {};\nIteratorPrototype[iteratorSymbol] = function() {\n    return this;\n}\n\nfunction Generator() {}\nfunction GeneratorFunction() {}\nfunction GeneratorFunctionPrototype() {}\n\nvar Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\nGeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\nGeneratorFunctionPrototype.constructor = GeneratorFunction;\nGeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\";\n\nfunction mark(genFun) {\n    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n}\n// 这里创建了一个奇怪的原型链\nGeneratorFunction.prototype = GeneratorFunctionPrototype;\nGeneratorFunctionPrototype.prototype = Object.create(IteratorPrototype);\ngenFun.__proto__ = GeneratorFunctionPrototype = GeneratorFunction.prototype;\ngenFun.prototype = Object.create(GeneratorFunctionPrototype.prototype);\n\n// 所以，genFun 是一个 GeneratorFunction 的实例\n// genFun 继承自 Generator(GeneratorFunctionPrototype), Generator(GeneratorFunctionPrototype) 又继承自 Iterator\n\n// 在 Iterator 实例上个挂载迭代器的方法\n[\"next\", \"throw\", \"return\"].forEach(function(method) {\n    Gp[method] = function(arg) {\n        return this._invoke(method, arg);\n    };\n});\n\nfunction wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    // 创建一个 genFun 实例\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // 一个全局变量\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n}\n\nvar GenStateSuspendedStart = \"suspendedStart\";\nvar GenStateSuspendedYield = \"suspendedYield\";\nvar GenStateExecuting = \"executing\";\nvar GenStateCompleted = \"completed\";\n\nfunction makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n            if (context.method === \"next\") {\n                // Setting context._sent for legacy support of Babel's\n                // function.sent implementation.\n                context.sent = context._sent = context.arg;\n\n            } else if (context.method === \"throw\") {\n                if (state === GenStateSuspendedStart) {\n                    state = GenStateCompleted;\n                    throw context.arg;\n                }\n                context.dispatchException(context.arg);\n            } else if (context.method === \"return\") {\n                context.abrupt(\"return\", context.arg);\n            }\n\n            state = GenStateExecuting;\n\n            // 调用 innerFn, 拿到返回值\n            var record = tryCatch(innerFn, self, context);\n            if (record.type === \"normal\") {\n                // If an exception is thrown from innerFn, we leave state ===\n                // GenStateExecuting and loop back for another invocation.\n                state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n                if (record.arg === ContinueSentinel) {\n                    continue;\n                }\n\n                return {\n                    value: record.arg,\n                    done: context.done\n                };\n\n            } else if (record.type === \"throw\") {\n                state = GenStateCompleted;\n                // Dispatch the exception by looping back around to the\n                // context.dispatchException(context.arg) call above.\n                context.method = \"throw\";\n                context.arg = record.arg;\n            }\n        }\n    }\n}\n\nfunction tryCatch(fn, obj, arg) {\n    try {\n        return {\n            type: \"normal\",\n            arg: fn.call(obj, arg)\n        };\n    } catch (err) {\n        return {\n            type: \"throw\",\n            arg: err\n        };\n    }\n}\n\n// 主函数\n\"use strict\";\n\n// outerFn\nvar _marked =\n/*#__PURE__*/\nmark(bar);\n\nfunction bar() {\n    return wrap(function bar$(_context) {\n        // innerFn\n        while (1) {\n            switch (_context.prev = _context.next) {\n                case 0:\n                _context.next = 2;\n                return 1;\n\n                case 2:\n                _context.next = 4;\n                return 2;\n\n                case 4:\n                _context.next = 6;\n                return 3;\n\n                case 6:\n                _context.next = 8;\n                return 4;\n\n                case 8:\n                return _context.abrupt(\"return\", 5);\n\n                case 9:\n                case \"end\":\n                return _context.stop();\n            }\n        }\n    }, _marked);\n}\n```","tags":["es6"]},{"title":"__proto__ 和 prototype","url":"/blog/2019/04/06/proto&prototype/","content":"\n**js 中的面向对象有非常多的版本，知道 es6 之后才统一规范，而且实例中有一些属性能帮我们找到实例的构造函数。**\n\n## 一、__proto__\n\n**__proto__ 是一个对象实例的属性，而对象实例是通过 new 关键字返回的，我们先来看看使用 js 来模拟一个 new 关键字。**\n\n``` js\nfunction myNew(fun) {\n    var obj = {};\n    if(fun.prototype !== null){\n    // 将实例的proto指向构造函数的原型\n        obj.__proto__ = fun.prototype;\n    }\n\n    // 如果构造函数有返回结果，用ret接收,通过apply,将构造函数的this指向实例res;\n    var ret = fun.call(obj, Array.prototype.slice.call(arguments,1));\n\n    if((typeof ret === 'object' || typeof ret === 'function' ) && ret != null){\n        return ret;\n    } else {\n        return obj;\n    }\n}\n```\n\n**由此可见，对象实例的 __proto__ 指向创建这个实例的类的原型 prototype，当查找实例上没有的属性时，会去查找 __proto__ 上的属性。而在原型上，都会有一个 constructor 指向构造函数。如下图**\n\n![es3 proto](../../../../img/proto&prototype/es3_proto.png)\n\n**使用 es6 的 class 语法糖得到结果和上述一样。**\n\n![es6 proto](../../../../img/proto&prototype/es6_proto.png)\n\n### Object.getPrototypeOf\n\n**对于这个方法官方的说法是，Object.getPrototypeOf() 方法返回指定对象的原型（内部[[ Prototype ]]属性的值）。而事实上，因为 [__proto__ 属性是被 Web 标准弃用的属性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)，推荐使用 Object.getPrototypeOf 来代替 __proto__。**\n\n## 二、prototype\n\n**prototype 原型看似和 __proto__ 类似，都是原型的意思，不过 [prototype 是用于类（构造函数）的，而 __proto__ 是用于实例的（instances）](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#prototype_%E5%92%8C_Object.getPrototypeOf)。而类（构造函数）的 prototype 在 new 这个实例的时候使用。**\n\n**我们来看一下 babel 实现的继承。**\n\n``` js\n// 源代码\nclass A{\n\tconstructor(name) { this.name = name; }\n  \n    static prop = 1;\n\n\tsayName() {\n\t\tconsole.log(this.name);\n\t}\n};\n\nclass B extends A {\n    constructor(name, age) {\n\t\tsuper(name); this.age = age \n\t}\n  \n    sayDetail() {\n\t\tsuper.sayName();\n\t\tconsole.log(this.age);\n\t}\n};\n\n// babel 转义代码\n// 实现 Reflect.get\nfunction _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n        _get = Reflect.get;\n    } else {\n        _get = function _get(target, property, receiver) {\n            var base = _superPropBase(target, property);\n            if (!base)\n                return;\n            var desc = Object.getOwnPropertyDescriptor(base, property);\n            if (desc.get) {\n                return desc.get.call(receiver);\n            }\n            return desc.value;\n        }\n        ;\n    }\n    return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n        object = _getPrototypeOf(object); // 取实例的原型\n        if (object === null)\n            break;\n    }\n    return object;\n}\n\n// 在原型上定义属性和方法，这些方法都是不可枚举的\nfunction _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\"in descriptor)\n            descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\n\n// 创造类，向原型上定义方法或者在类上定义静态属性\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n        _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n    // 用父的原型创造一个实例\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n\n    // 将子类的 __proto__ 设为 父类，在 es5 中没有这一步操作\n    if (superClass) {\n        _setPrototypeOf(subClass, superClass);\n    }\n}\n\nvar A = /*#__PURE__*/\nfunction() {\n    function A(name) {\n        this.name = name;\n    }\n\n    _createClass(A, [{\n        key: \"sayName\",\n        value: function sayName() {\n            console.log(this.name);\n        }\n    }]);\n\n    return A;\n}();\n\n_defineProperty(A, \"prop\", 1);\n\nvar B = /*#__PURE__*/\nfunction(_A) {\n    _inherits(B, _A);\n\n    function B(name, age) {\n        var _this;\n\n        // 调用父的构造函数，在 es5 中直接调用 A.call(this, name)\n        _this = _getPrototypeOf(B).call(this, name); \n        _this.age = age;\n\n        return _this;\n    }\n\n    _createClass(B, [{\n        key: \"sayDetail\",\n        value: function sayDetail() {\n            // 调用父原型上的方法\n            _get(_getPrototypeOf(B.prototype), \"sayName\", this).call(this);\n\n            console.log(this.age);\n        }\n    }]);\n\n    return B;\n}(A);\n```\n\n**B.prototype 是一个以 A.prototype 为原型创造的实例，也就是说，B.prototype 是一个 A对象的实例。所以说 prototype 是用于类（构造函数） B，且通过 new 关键字创造的实例，默认没有 prototype 而是 __proto__。**\n\n**以前的 es5 版本的继承，不会将子类的 __proto__人为设为父类（一般只有通过 new 关键字得到的实例才会有__proto__），但在 es6 规范出来之后多出来这一步。es6 中的方法在 prototype 上是无法枚举的属性。这个 __proto__ 不仅仅将两个类关联起来这么简单，它还实现了父类上的静态属性的继承。当取不到子类的静态属性时，会去父类找静态属性（子类的 __proto__），如下。**\n\n![extends static](../../../../img/proto&prototype/extends_static.png)\n\n## 三、网上神图\n\n**copy 一张网上的超级复杂的[原型链神图](https://blog.csdn.net/cc18868876837/article/details/81211729)。**\n\n![copy prototype](../../../../img/proto&prototype/copy_prototype.png)\n\n**针对原博客再总结几点：**\n\n**1.所有的 prototype 都是对象实例，所以 Foo.prototype 和 Function.prototype 的 __proto__ 都指向 Object.prototype，而 Object.prototype 的 __proto__ 属性为 null。**\n\n**2.最左边一条是典型的原型链继承，对于实例 f1，f1 上找不到的属性会在 f1 的 __proto__ 对象里面找，依次往上。而对于构造函数来说，构造函数的 prototype 属性都是父类的实例。**\n\n**3.这张图中的继承关系是 Foo extends Object，而不是 Foo extends Function，Foo 是 Function 的实例。此处调用 Foo.prototype.isPrototypeOf(f1) 和 Object.prototype.isPrototypeOf(f1) 都为true。这里有一个特殊情况，isPrototypeOf 无法判断基本变量，但是本质上，它和 f1 一样，也是从对象继承而来，万物皆对象。如图：**\n\n![everything is object](../../../../img/proto&prototype/everything_is_object.png)\n\n**4.Object 和 Foo 都是构造函数，所以都继承自 Function，不仅如此所有的构造函数都继承自 Function，如 String、Number、Date。它们的 __proto__ 都指向 Function.prototype。**\n\n**5.Function 的构造函数是他自己，所以右上角会有一条奇怪的链，Function 的 __proto__ 和 prototype 都是 Function.prototype。**\n","tags":["prototype"]},{"title":"js 中的“魔鬼”","url":"/blog/2019/04/05/es3_leak/","content":"\n## 一、eval 导致闭包引用不释放\n\n### 利用 weakSet 查看内存引用。\n\n**首先来讲一下如何看内存泄漏。第一我们可以利用 devTool 中的 Memory 来查看内存，其次 es6 中出现了 WeakSet 数据结构，它的好处就是 GC 收回内存时，不会计算 WeakSet 中的引用，可以利用他来看一些内存是否已被回收。**\n\n``` js\nlet obj = {a: {}};\n\nlet weakset = new WeakSet([obj.a]);\nconsole.log(weakset.has(obj.a)); // true，此时若打印 weakset 可以看到里面包含了一个对象\n\n// console.log(obj.a)\n// 若此处打印了 obj.a 对象，则会在控制台中保存 obj.a 的引用，会导致下面触发 GC 的时候不回收对象\n// 当然也可以清空控制台之后再触发 GC\n\ndelete obj.a;\n// 因为 GC 不是随时触发的，此时一定要点一下 devTool 中的 Memory 里的\nconsole.log(weakset); // 打印出一个空的 weakset\n```\n\n### 内存泄漏\n\n**然后我们利用 WeakMap 来查看一个 eval 对闭包的影响。**\n\n``` js\nclass Jqx {};\nlet weakset =  new WeakSet();\n// 正常的闭包\nfunction test() {\n    let jqx = new Jqx();\n    let jqx2 = new Jqx();\n\n    weakset.add(jqx);\n    weakset.add(jqx2);\n\n    return function () {\n        return jqx;\n    }\n}\n\nlet getJqx = test();\n// 手动触发 GC\nconsole.log(weakset); // WeakSet {Jqx}，只有一个对象\n```\n\n**上面闭包没有对 jqx2 的引用，所以 GC 会回收，通过内存快照得到下面结果。**\n\n![no_eval](../../../../img/es3_leak/no_eval.png)\n\n``` js\nclass Jqx {};\nlet weakset =  new WeakSet();\n// 带 eval 的闭包\nfunction test() {\n    let jqx = new Jqx();\n    let jqx2 = new Jqx();\n\n    weakset.add(jqx);\n    weakset.add(jqx2);\n\n    return function () {\n        eval('');\n    }\n}\n\nlet getJqx = test();\n// 手动触发 GC\nconsole.log(weakset); // WeakSet {Jqx, Jqx}，两个对象都在\n```\n\n**上面闭包中有 eval，因为 eval 是在运行时才会将其中的字符串转为 js，所以 js 引擎保留了整个闭包中的所有的内容。通过内存快照得到下面结果。**\n\n![eval](../../../../img/es3_leak/eval.png)\n\n**此外，eval也容易引起网站被攻击，不到万不得已就不要使用了。**\n\n## 二、new Function\n\n**讲完 eval，再来说说 new Function。Function 的调用与 eval 相似，不过 Function 中若有变量，则都指向全局变量，而不会对闭包中的变量进行引用，所以也不会像 eval 一样造成内存泄漏。**\n\n``` js\nvar name = 'jqx';\nvar test = function () {\n    var name = 'jqx2';\n    return new Function('console.log(name)');\n}\n\ntest()(); // 打印 jqx\n```\n\n## 三、with\n\n**说到 eval 肯定也要提一嘴 with，俩兄弟双双欺骗词法作用域（在运行时改变作用域）。**\n\n``` js\nvar obj = {\n    name: 'jqx'\n}\n\nwith (obj) {\n    name = 'jqx2';\n    job = 'programmer'; // 若对象 obj 上没有 job 属性，则赋值到 window 上\n}\n\nconsole.log(obj.name);\nconsole.log(obj.job);\nconsole.log(window.job);\n```\n\n## 四、严格模式下的 eval 和 with\n\n**严格模式下 with 就直接被禁用了，而 eval 无法修改作用域。不过 eval 还是可以引用到闭包中的变量，所以闭包还是不会被释放。**\n\n``` js\nclass Jqx {};\nlet weakset =  new WeakSet();\n// 带 eval 的闭包\nfunction test() {\n    \n    let jqx = new Jqx();\n    let jqx2 = new Jqx();\n\n    weakset.add(jqx);\n    weakset.add(jqx2);\n\n    return function () {\n\t\t'use strict';\n        eval('console.log(jqx);var a = 1;');\n\t\tconsole.log(a);\n    }\n}\n\nlet getJqx = test();\n// 手动触发 GC\nconsole.log(weakset); // WeakSet {Jqx, Jqx}，两个对象都在\n\ngetJqx(); \n// 打印对象 jqx\n// 报错 a 不存在\n```","tags":["leak"]},{"title":"不会测试的UI不是好前端","url":"/blog/2019/03/29/web-qa/","content":"\n**自 js 崛起，GitHub 上有越来越多的开源项目，而每个项目的根目录下必然会有 test，用来做项目的自测。js 已经入侵测试领域了。**\n\n**本贴记录一些常用的测试库，和基本使用方法。**\n\n## 一、单元测试\n\n**使用 karma、phantomjs（无头浏览器） 进行单元测试（小函数、功能），并使用 karma-coverage 生成报表。**\n\n**使用 npm 安装 karma，karma-coverage，jasmine-core，karma-jasmine，karma-phantomjs-launcher。然后调用 karma init 进行初始化，在根目录下得到 karma.conf.js 文件。配置如下：**\n\n```js\n{\n    basePath: '',\n    frameworks: ['jasmine'],\n    files: [\n      './tests/unit/*.js',\n      './tests/unit/*.spec.js'\n    ],\n    exclude: [\n    ],\n    preprocessors: {\n      './tests/unit/**/*.js': ['coverage']\n    },\n    reporters: ['progress', 'coverage'],\n    coverageReporter: {\n      type: 'html',\n      dir: './docs/coverage/'\n    },\n    port: 9876,\n    colors: true,\n    logLevel: config.LOG_INFO,\n    autoWatch: false,\n    browsers: ['PhantomJS'],\n    singleRun: true,\n    concurrency: Infinity\n  }\n```\n\n**/tests/unit/index.js 文件**\n\n```js\nfunction add(num) {\n    if (num === 1) {\n        return 1;\n    }\n    \n    return num + 1;\n}\n```\n\n**/tests/unit/index.spec.js 文件**\n\n```js\ndescribe('加一函数测试', function () {\n    it('加一函数是否可用', function () {\n        // expect(add(1)).toBe(1);\n        expect(add(2)).toBe(3);\n    });\n})\n```\n\n**运行 karma start 得到如下报表，其中得到测试结果以及提醒测试js中有部分代码没有覆盖到。**\n\n![unit test reporters](../../../../img/web_qa/unit_test_reporters.png)\n\n## 二、性能测试\n\n## 三、安全测试\n\n## 四、功能测试\n\n### 模拟用户操作\n\n**使用 selenium-webdriver 模拟用户操作。**\n\n**用 npm 安装 selenium-webdriver，并在 selenium-webdriver 的npm 网站上下载相关浏览器的 driver，解压在根目录下。**\n\n**以下是调用 selenium-webdriver 的官方例子，node运行如下js，测试结果在终端输出。**\n\n```js\nconst { Builder, By, Key, until } = require('selenium-webdriver');\n\n(async function example() {\n    let driver = await new Builder().forBrowser('chrome').build();\n    try {\n        await driver.get('http://www.baidu.com');\n        await driver.findElement(By.name('wd')).sendKeys('webdriver', Key.ENTER);\n        await driver.wait(until.titleIs('webdriver_百度搜索'), 3000);\n    } finally {\n        await driver.quit();\n    }\n})();\n```\n\n![e2e test](../../../../img/web_qa/e2e_test.png)\n\n\n\n### 后台服务测试\n\n**使用 mocha 进行后台接口数据测试。**\n\n**使用 npm 安装 express（node服务库），mocha，mochawesome（生成报表），supertest（代理服务）**\n\n**app.js 文件**\n\n``` js\nconst express = require('express');\nconst app = express();\n\napp.get('/data', (req, res) => {\n    res.send({\n        name: 'jqx'\n    })\n})\n\nconst server = app.listen(3000, () => {\n    console.log('server start at 3000');\n});\n\nmodule.exports = app;\n```\n\n**app.spec.js 文件**\n\n```js\nconst superagent = require('supertest');\nconst app = require('./app.js');\n\nfunction req() {\n    return superagent(app.listen());\n}\n\ndescribe('node 接口测试', () => {\n    it('data 接口测试', done => {\n        req()\n            .get('/data')\n            .expect(200)\n            .expect('Content-Type', /json/)\n            .end((err, res) => {\n                if (err) {\n                    done(err);\n                }\n\n                if (res.body.name === 'jqx') {\n                    done();\n                } else {\n                    done(new Error('名字错误'));\n                }\n            })\n    })\n})\n```\n\n**根目录下创建 mochaRunner.js 文件**\n\n```js\nconst Mocha = require('mocha');\n\nlet mocha = new Mocha({\n    reporter: 'mochawesome',\n    reporterOptions: {\n        reportDir: './docs/customReportFilename',\n        // quiet: true\n    }\n});\n\nmocha.addFile('app.spec.js');\nmocha.run(() => {\n    process.exit();\n})\n```\n\n**node 运行 mochaRunner.js，并生成报表**\n\n![mocha test](../../../../img/web_qa/mocah_test.png)\n\n## 五、UI测试\n\n**使用 backstopjs 进行 ui 测试。**\n\n**使用 npm 安装 backstopjs。安装完后运行 backstop init 命令初始化。**\n\n**配置根目录下的 backstop.json**\n\n``` js\n{\n  \"id\": \"taobao\",\n  \"viewports\": [\n    { // 测试网页的尺寸\n      \"label\": \"phone\",\n      \"width\": 320,\n      \"height\": 480\n    },\n    {\n      \"label\": \"tablet\",\n      \"width\": 1024,\n      \"height\": 768\n    }\n  ],\n  \"onBeforeScript\": \"puppet/onBefore.js\",\n  \"onReadyScript\": \"puppet/onReady.js\",\n  \"scenarios\": [\n    {\n      \"label\": \"taobao index\",\n      \"cookiePath\": \"backstop_data/engine_scripts/cookies.json\", // 如果需要cookie则进行配置\n      \"url\": \"https://h5.m.taobao.com/?sprefer=sypc00\", // 测试网页的地址\n      \"referenceUrl\": \"\",\n      \"readyEvent\": \"\",\n      \"readySelector\": \"\",\n      \"delay\": 0,\n      \"hideSelectors\": [],\n      \"removeSelectors\": [],\n      \"hoverSelector\": \"\",\n      \"clickSelector\": \"\",\n      \"postInteractionWait\": 0,\n      \"selectors\": [],\n      \"selectorExpansion\": true,\n      \"expect\": 0,\n      \"misMatchThreshold\" : 0.1,\n      \"requireSameDimensions\": true\n    }\n  ],\n  \"paths\": {\n    \"bitmaps_reference\": \"backstop_data/bitmaps_reference\", // ui 原图路径\n    \"bitmaps_test\": \"backstop_data/bitmaps_test\",\n    \"engine_scripts\": \"backstop_data/engine_scripts\",\n    \"html_report\": \"./docs/backstop_data/html_report\", // 测试报表生成地址\n    \"ci_report\": \"./docs/backstop_data/ci_report\"\n  },\n  \"report\": [\"browser\"],\n  \"engine\": \"puppeteer\",\n  \"engineOptions\": {\n    \"args\": [\"--no-sandbox\"]\n  },\n  \"asyncCaptureLimit\": 5,\n  \"asyncCompareLimit\": 50,\n  \"debug\": false,\n  \"debugWindow\": false\n}\n```\n\n**运行 backstop test 进行测试。生成报表中，像素点不同之处都会标红，如下**\n\n![backstop test](../../../../img/web_qa/backstop_test.png)","tags":["qa"]},{"title":"函数式编程 - 函子","url":"/blog/2019/03/24/Lambda/","content":"\n**函数式编程通过管道把数据在一系列纯函数间传递。但是，控制流（control flow）、异常处理（error handling）、异步操作（asynchronous actions）和状态（state）呢？还有更棘手的作用（effects）呢？我们都将借助函子帮我们完成。**\n\n**函子是函数式编程中最重要的数据类型，也是基本的运算单位和功能单位。**\n\n## 一、容器\n\n**我们创建一个容器，这个容器就职于装载值，并且不会向容器添加新属性或者方法。**\n\n``` js\nclass Container {\n    constructor (value) {\n        this.__value = value;\n    }\n\n    static of(value) {\n        return new this(value);\n    }\n\n    map(f) {\n        return Container.of(f(this.__value));\n    }\n}\n\nlet concat = x => y => y.concat(x);\nlet prop = x => y => y[x];\n\nContainer.of(\"bombs\") // Container('bombs')\n    .map(concat(' away')) // Container('bombs away')\n    .map(prop('length')) // Container(10)\n```\n\n**这样我们就能够在不离开 Container 的情况下操作容器里面的值，并且这很函数式。**\n\n## 二、Maybe\n\n**错误处理时，可以使用 Maybe 函子**\n\n``` js\nclass Maybe extends Container {\n    constructor (value) {\n        super(value);\n    }\n\n    isNothing() {\n        return (this.__value === null || this.__value === undefined);\n    }\n\n    map(f) {\n        return this.isNothing() ? Maybe.of(null) : Maybe.of(f);\n    }\n}\n\nlet retNull = () => null;\n\nMaybe.of(\"bombs\") // Maybe('bombs')\n    .map(concat(' away')) // Maybe('bombs away')\n    .map(retNull) // Maybe(null)\n    .map(prop('length')) // 当检测到 value 为null，不运行 prop 函数，避免函数运行时报错，返回 Maybe(null)\n```\n\n## 三、Either\n\n**数学中没有 if...else，我们可以用 either 纯函数来处理 if...else**\n\n``` js\nclass Either extends Container {\n    constructor(left, right) {\n        super();\n        this.left = left;\n        this.right = right;\n    }\n\n    static of(left, right) {\n        return  new this(left, right);\n    }\n\n    map(f) {\n        return this.right ? \n            Either.of(this.left, f(this.right)) :\n            Either.of(f(this.left), this.right);\n    }\n}\n\nlet lenLtNum = num => str => str.length < num;\nlet lenLt4 = lenLtNum(4);\n\nEither.of(\"jqx\", \"bombs\") // Either(\"jqx\", \"bombs\")\n    .map(lenLt4) // Either(\"jqx\", false)\n    .map(concat(' away')) // Either(\"jqx away\", false)\n    .map(prop('length')) // Either(8, false)\n```\n\n## 四、IO\n\n**我们有很多的不纯的操作，如取 storage 缓存，向后台请求接口，我们把这些函数包装在IO函子中，让调用者替我们承当不纯的部分。**\n\n``` js\nclass IO extends Container {\n    constructor(f) {\n        super(f);\n    }\n\n    map(f) {\n        return new IO(_.compose(f, this.__value));\n    }\n}\n\nlet retWin = () => window;\nlet getInnerWidth = win => win.innerWidth;\nlet unsafeWidth = IO.of(retWin).map(getInnerWidth);\n\nunsafeWidth.__value(); // 调用不纯函数得到窗口宽度\n```\n\n## 五、Monad\n\n**下面有两个不纯的函数，但是把他们包装一下，每次都返回 IO 函子，包装他们的函数是一个纯函数。**\n\n``` js\nconst fs = require('fs');\n\nlet readFile = function(filename) {\n    return new IO(function() {\n        return fs.readFileSync(filename, 'utf-8');\n    });\n};\n\nlet print = function(x) {\n    return new IO(function() {\n        console.log(x);\n        return x;\n    });\n}\n\nlet getUser = readFile('./user.txt') // IO{ val: f => user }\n                .map(print) // IO{ val: f => IO { f => user }}\n\ngetUser.__value().__value(); // 拿到 user\n```\n\n**若 IO 函子 map 了一个不纯的函数，则会得到一个 IO 里面包装 IO 的函子，提供一个 Monad 函数处理这种情况。**\n\n``` js\nclass Monad extends Container {\n    join() {\n        return this.__value;\n    }\n\n    flatMap(f) {\n        return this.map(f).join();\n    }\n}\n\nclass IO extends Container {\n    map(f) {\n        return new IO(_.compose(f, this.__value));\n    }\n\n    flatMap(f) {\n        // 这里要扩展父的 flatMap 是因为 IO 函子里面放的是函数，\n        // 得将之运行一下，返回输出的 IO 扁平化，若函子里面放的是纯数据则不需要扩展\n        return super.flatMap(f)();\n    }\n}\n\nlet getUser = readFile('./user.txt') // IO{ val: f => user }\n                .flatMap(print) // IO{ val: f => IO { f => user }}\n\ngetUser.__value(); // 拿到 user\n\nlet getName = prop('name');\n\nlet getUserName = readFile('./user.txt') // IO{ val: f => user }\n                .flatMap(print) // IO{ val: f => IO { f => user }}\n                .map(getName)\n\ngetUserName.__value(); // 拿到 userName\n```\n","tags":["lambda"]},{"title":"函数式编程","url":"/blog/2019/03/19/functional/","content":"\n<script src=\"https://cdn.bootcss.com/lodash.js/4.17.12-pre/lodash.js\"></script>\n\n**js中函数是一等公民，这句话意味着函数和其他数据类型一样，可以赋值给其他变量，也可以作为参数传入另一个函数，或者作为别的函数的返回值。**\n\n# 一、纯函数\n\n**对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的函数称之为纯函数**\n\n``` js\nlet xs = [1, 2, 3, 4, 5];\n\n// slice 是纯函数，固定输入得到固定输出，没有副作用\nxs.slice(0, 3) // [1, 2, 3] xs不变\nxs.slice(0, 3) // [1, 2, 3] xs不变\nxs.splice(0, 3) === xs.splice(0, 3) // [1, 2, 3] xs变成[4, 5]\nxs.splice(0, 3) === xs.splice(0, 3) // [4, 5] xs变成[]\n```\n\n## 纯函数的优点\n\n### 可缓存性\n**由于固定输入得到固定输出，所以可以将函数结果缓存起来。**\n\n``` js\nimport _ from 'loadsh';\nconst sin = _.memorize(x => Math.sin(x));\n\nsin(1);\n\n// 第二次计算有了换成。速度会变快\nsin(2);\n```\n\n### 可移植性\n\n**命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它。**\n\n``` js\n// 不纯的\nvar signUp = function(attrs) {\n  var user = saveUser(attrs);\n  welcomeUser(user);\n};\n\nvar saveUser = function(attrs) {\n    var user = Db.save(attrs);\n    ...\n};\n\nvar welcomeUser = function(user) {\n    Email(user, ...);\n    ...\n};\n\n// 纯的\nvar signUp = function(Db, Email, attrs) {\n  return function() {\n    var user = saveUser(Db, attrs);\n    welcomeUser(Email, user);\n  };\n};\n\nvar saveUser = function(Db, attrs) {\n    ...\n};\n\nvar welcomeUser = function(Email, user) {\n    ...\n};\n```\n\n### 可测试性\n\n**纯函数让测试更加容易。只需简单地给函数一个输入，然后断言输出就好了。**\n\n# 二、函数柯里化\n\n**传给函数部分参数，返回一个函数处理剩下的参数。**\n\n``` js\nlet comparedAge = (min, age) => min < age;\n\nlet initMinAge = (min) => {\n    return (age) => comparedAge(min, age)\n}\n\nlet checkAge19 = initMinAge(19);\n\ncheckAge19(15); // false\ncheckAge19(23); // true\n```\n\n**以下为个人查阅 lodash 源码，制作的简化版的 curry**\n\n``` js\nconst curry = (func, partials, arity=func.length)=>{\n    const wrapper = function() {\n        let length = arguments.length;\n        let args = Array(length);\n        let index = length;\n\n        while (index--) {\n            args[index] = arguments[index];\n        }\n\n        if (partials) {\n            args = args.concat(partials);\n        }\n\n        if (length < arity) {\n            return curry(func, args, arity - length);\n        }\n\n        return func.apply(window, args.reverse());\n    }\n    return wrapper;\n}\n\nlet abc = function(a, b, c) {\n    return [a, b, c];\n};\n\nlet a = curry(abc);\n\nconsole.log(a(1)(2)(3)); // [1, 2, 3]\n\nlet b = a(4);\nconsole.log(b(5)(6)); // [4, 5, 6]\n\nlet c = a(7)(8);\nconsole.log(c(9)); // [7, 8, 9]\n```\n\n# 三、代码组合\n\n**f 和 g 都是函数，x 是在它们之间通过“管道”传输的值。特性有结合律，符合结合律意味着不管你是把 g 和 h 分到一组，还是把 f 和 g 分到一组都不重要。**\n\n``` js\nvar compose = function(f,g) {\n    return function(x) {\n        return f(g(x));\n    };\n};\n\n// 结合律（associativity）\nvar associative = compose(f, compose(g, h)) == compose(compose(f, g), h);\n// true\n```\n\n## pointfree\n\n**函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。**\n\n``` js\n// 非 pointfree，因为提到了数据：word\nvar snakeCase = function (word) {\n    return word.toLowerCase().replace(/\\s+/ig, '_');\n};\n\n// pointfree\nvar replace = function (reg, replaceStr) {\n    return function (str) {\n\t\treturn str.replace(reg, replaceStr);\n\t}\n}\n\nvar toLowerCase = function (str) {\n\treturn str.toLowerCase();\n}\n\nvar snakeCase = compose(replace(/\\s+/ig, '_'), toLowerCase);\n\nsnakeCase('A B'); // a_b\n```\n\n## debug\n\n**如果在 debug 组合的时候遇到了困难，那么可以使用下面这个实用的，但是不纯的 trace 函数来追踪代码的执行情况。**\n\n``` js\nvar trace = curry(function(tag, x){\n  \tconsole.log(tag, x);\n  \treturn x;\n});\n\nvar snakeCase = compose(replace(/\\s+/ig, '_'), compose(trace('[snakeCase]'), toLowerCase));\n\nsnakeCase('A B');\n// log  [snakeCase] a b\n// 返回 a_b\n```\n\n# 四、尾递归\n\n**尾递归的判断标准是函数的最后一步是否调用自身。尾递归调用栈永远都是更新当前的栈帧，这样就避免了爆栈的危险，而浏览器并未支持，原因有 1.在引擎曾消除递归是隐式行为，程序员意识不到。2. 堆栈信息丢失导致开发者难以调试。我们可以将递归写成while。**\n\n``` js\n// 传统递归\nfunction sum(n) {\n    if (n === 1) return 1;\n    return n + sum(n - 1);\n}\n\nsum(5);\n// 调用栈\nsum(5)\n(5 + sum(4))\n(5 + (4 + sum(3)))\n(5 + (4 + (3 + sum(2))))\n(5 + (4 + (3 + (2 + sum(1)))))\n(5 + (4 + (3 + (2 + 1))))\n(5 + (4 + (3 + 3)))\n(5 + (4 + 6))\n(5 + 10)\n15\n\n// 尾递归调用\nfunction sum(n, total = 0) {\n    if (n === 1) return n + total;\n    return sum(n - 1, n + total);\n}\n\nsum(5);\n// 调用栈，每次调用栈都指向新返回的函数\nsum(5)\nsum(4, 5)\nsum(3, 9)\nsum(2, 12)\nsum(1, 14)\n15\n```","tags":["functional"]},{"title":"使用 async 同步处理 websocket 返回","url":"/blog/2019/03/17/async-websocket/","content":"\n**在使用 websocket（下文叫ws） 与交互时，使用 send 方法发送数据，监听 message 事件接受数据，以前的做法是在 message 触发时触发回调函数，而在 es6 中也可以使用 async 同步处理数据。**\n\n## 一、确定 ws 数据\n\n**ws 不像 http，当你用 ws 发送了2条请求，当然也会收到2条响应，但是你不知道的是，哪一条响应对应哪一条请求。**\n\n**在开发时，我一般会在协议里带上 method,以此来标记响应对应的请求**\n\n``` js\n// 请求数据\n{\n    method: 'getEmail',\n    data: {\n        id: 1\n    }\n}\n\n// 响应的数据\n{\n    method: 'getEmail',\n    data: {\n        email: 'xxx@xx.com'\n    }\n}\n```\n\n**不过当发送了多个相同 method 的请求还是无法区分响应对应哪一条请求，可以在协议里加上id，使其在每次发送 ws 请求时自增长，并且响应时带上这个 id。若 id 相同则为对应的响应**\n\n## 二、处理 message\n\n### 回调函数\n\n**以前会定义一个 key 为 method，value 为对应回调函数的 json 来处理响应。这种方法就让业务逻辑中多了一层回调函数。**\n\n``` js\n// 发送\nws.send(JSON.stringify(\n    { method: 'getEmail' }\n));\n\n// 回调\nlet wsCb = {\n    getEmail(data) {\n        // 回调逻辑\n    }\n}\n\nws.onmessage = function (e) {\n    let {data: {method}} = e;\n\n    let fn = wsCb?.[method];\n    fn && fn();\n}\n```\n\n### async 处理回调\n\n**使用 async 可以将异步改同步，并且减少回调函数的使用。**\n\n``` js\n// 回调\nlet wsCb = {}\n\nws.onmessage = function (e) {\n    let data = e.data;\n    let method = data.method;\n\n    let fn = wsCb?.[method];\n    delete wsCb.[method];\n\n    fn && fn(data);\n}\n\nlet wsSend = (data) => {\n    ws.send(JSON.stringify(data);\n\n    let methos = data.methos;\n    return new Promise (res, rej) {\n        wsCb[methos] = function (data) {\n            res(data);\n        }\n    }\n}\n\n// 主业务\n(async () => {\n    let req = { method: 'getEmail' };\n\n    let res = await wsSend(req);\n\n    console.log(res)\n})()\n```\n\n### 使用事件处理函数\n\n**js 中有很多事件处理的库，可以用来管理自定义的事件，这里就拿 jQuery 的事件绑定来做例子（jQuery 的实现方式见之前的[博客](../../../../2019/03/04/jquery-technology-insider/)）。**\n\n``` js\nclass ws {\n    constructor () {\n        let ws = new WebSocket();\n        \n        this.ws = ws;\n        this.initEvent();\n    }\n\n    initEvent() {\n        let ws = this.ws;\n\n        ws.onopen = function () {};\n        ws.onmessage = function (e) {\n            let data = e.data;\n            let method = data.method;\n\n            $(this).trigger(method, [data]);\n        };\n    }\n\n    send(data) {\n        let ws = this.ws;\n        let method = data.method;\n\n        ws.send(data);\n\n        return new Promise (res, rej) {\n            $(this).one(method, (data) => {\n                res(data);\n            })\n        }\n    } \n}\n\n// 主业务\n(async () => {\n    let ws = new ws();\n    let req = { method: 'getEmail' };\n\n    let res = await ws.send(req);\n\n    console.log(res)\n})()\n```","tags":["async"]},{"title":"js 小细节","url":"/blog/2019/03/12/js_details/","content":"\n**此贴用来记录一些 js 的小细节（常见坑）**\n\n### 一、js 不能没有分号！！\n\n**先标题档一下，js 可以没有分号，但是某些时候又不得不加分号。在使用立即执行函数，容易在开头漏掉分号，以至于 js 把上一行的返回当成了一个函数来运行。**\n\n``` js\n(() => {alert(1)})() // alert 1\n(() => {alert(2)})() // 报错\n```\n\n### 二、同时声明同名函数与定义变量\n\n**在同时声明函数和定义变量时，如果没有给变量赋值，则函数生效。**\n\n``` js\nfunction foo() {}; // 定义函数在先\nvar foo;\n\nconsole.log(foo);\n// 打印 函数foo\n\nvar foo; // 定义变量在先\nfunction foo() {};\n\nconsole.log(foo);\n// 打印 函数foo\n```\n\n### 三、给变量赋值函数，且给函数名字。\n\n**给变量赋值函数，且给函数一个名字，在函数内部打印这个名字即指向该函数。函数内部无法给这个变量赋值，且外部无法获取这个变量。**\n\n``` js\nlet a = function foo() {\n    console.log(foo); // 打印 foo 函数\n    foo = 1;\n    console.log(foo); // 打印 foo 函数\n\n    // 若重新定义了 foo 变量，贼内部的 foo 不再指向函数。\n    // var foo = 1;\n    // console.log(foo); // 打印1\n}\n\nconsole.log(foo); // 报错 foo is not defined\n```\n\n---\n\n**2019-04-03 补充**\n\n**没有定义给属性的函数可以在函数内部重新定义函数名。**\n\n```js\nfunction test() {\n\tconsole.log(test);\n\ttest = 1;\n\tconsole.log(test);\n}\n\ntest(); // 打印 函数 和 1\ntest(); // 报错\n\n\nlet test = function test() {\n\tconsole.log(test);\n\ttest = 1;\n\tconsole.log(test);\n}\n\ntest();  \ntest(); // 无法修改 test 值，打印 4 次函数\n```\n\n### 四、不能 new es6 的函数\n\n**所谓 es6 的函数是指对象的简写函数和箭头函数。两者在 new 的时候都会报错，**\n\n``` js\nlet a = {\n    foo() {}\n}\n\nnew a.foo(); // a.foo is not a constructor\n\nlet foo = () => {};\n\nnew foo(); // foo is not a constructor\n```\n\n### 五、new 的时候，函数内的 this 指向创建的实例\n\n**在调用 new 的时候，函数内的 this 指向创建的实例，且不能通过 bind 来改变。**\n\n``` js\nvar obj = {\n    a: 10,\n    foo: function () {\n        console.log(this.a);\n    }\n}\n\nvar obj2 = {\n    a: 20\n}\n\nobj.foo() // 打印 10\nvar myFoo = obj.foo.bind(obj2);\nmyFoo(); // 打印 20\nnew myFoo(); // 打印 undefined\n```\n\n### 六、原型链属性失效\n\n**当实例中定义过属性，即使是 undefined，也不会取原型链上的属性。**\n\n``` js\nfunction foo(a) {\n    this.a = a;\n}\nfoo.prototype.a = 10;\n\nconsole.log((new foo()).a); // 打印 undefined\n```\n\n### 七、function 的变量提升\n\n**在老版本的浏览器中，声明函数会提升到当前函数作用域的顶端，在最后声明的函数在作用域内都可以使用。**\n\n``` js\nfoo(); // 打印 1\n\nif (false) {\n    function foo() {\n        console.log(1);\n    }\n}\n```\n\n**在支持 es5 的现代浏览器中，却是不同的结果。声明函数时，会先将定义变量（var foo）提升到<span style='color:Crimson;'>函数作用域</span>的顶端，然后在<span style='color:Crimson;'>块级作用域</span>顶端对函数赋值。**\n\n``` js\nconsole.log(foo); // foo 已经定义，打印 undefined\n{\n    console.log(foo); // foo 函数提升，打印 foo 函数\n    function foo() {};\n}\n\n\nfoo2(); // 报错 foo2 is not a function\n\nif (true) { // 不管是 true 还是 false，运行 foo2 时 foo2 还未赋值为函数\n    function foo2() {\n        console.log(1);\n    }\n}\n```\n\n### 八、严格模式\n\n**es5 中规定了严格模式后，给 js 增加了很多合理的规范，但是严格模式对函数中的函数不起作用。**\n\n``` js\nfunction useStrict() {\n    'use strict';\n    console.log(this);\n}\nuseStrict(); // 打印 undefined\n\nfunction noStrict() {\n    console.log(this);\n}\nnoStrict(); // 打印 window\n\nfunction useStrict2() {\n    'use strict';\n    noStrict();\n}\nuseStrict2(); // 打印 window\n```","tags":["js"]},{"title":"js和后台语言的差异","url":"/blog/2019/03/08/js-OOP/","content":"\n## 一、强类型\n\n**强类型优势：**\n**1.  数据类型固定不变，减少了程序由于数据类型问题报错的概率，保证程序健壮性。**\n**2.  所有变量类型确定，增加了一定可读性。**\n\n## 二、变量\n\n### var 声明变量\n\n**使用 var 关键字声明变量，会导致变量的提升。在 let 出现之后，这个问题很好的解决了。**\n\n``` js\nconsole.log(a);\nvar a = 1;\n// 打印 undefined\n\nconsole.log(a);\nlet a = 1;\n// 报错 b is not defined\n```\n\n### function 声明\n\n**使用 function 关键字声明函数时，会导致函数提升，提升的方式与浏览器的版本密切相关。**\n\n``` js\nfunction test() {\n    console.log('out');\n}\n\n(function () {\n    if (false) {\n        function test() {\n            console.log('in');\n        }\n    }\n\n    test()\n})()\n\n// 老版本浏览器 打印 in\n// 新版本浏览器 报错 test is not a function\n```\n\n**在ES6的浏览器中，它们的行为实际上是这样的：**\n\n**1.   允许块级作用域中定义函数。**\n\n**2.   函数声明实际上将会类似于使用 var 声明的函数表达式，函数名将会提升至当前函数作用域顶。**\n\n**3.   同时函数声明也会保持在块级作用域中的提升行为。**\n\n**上述代码在现代浏览器中类似：**\n\n``` js\nvar test;\ntest = function () {\n    console.log('out');\n}\n\n(function () {\n    var test;\n    if (false) {\n        test = function () {\n            console.log('in');\n        }\n    }\n\n    test();\n})()\n```\n\n## 三、this\n\n**一般后台语言中的 this 就指向当前class类，但js 中 this 是多变的，这已经是老生常谈了。js 中的 this 分了三种情况。**\n\n**1.   普通函数调用，this 指向window。**\n\n**2.   对象调用，this 指向调用方法的对象。**\n\n**3.   构造函数，this 指向返回的实例。**\n\n## 四、函数参数\n\n**js 中的函数在运行时，传入的参数与定义时的参数数量可以不同，在函数内可以通过 arguments 对象取得未定义的参数，这使 js 有时候变得方便，但是缺失了函数的重载（可以通过一些[技巧](../../06/js-skill/)实现函数重载）**\n\n## 五、数组\n\n**js 中的数组不是真的数组，他属于对象。当数组下标都是连续时，数组为快数组，而下标不连续时，数组就变成了 map。当操作只有出栈入栈时，js 数组的性能会不如 List。**\n\n**[从Chrome源码看JS Array的实现](https://zhuanlan.zhihu.com/p/26388217)**\n\n## 六、面向对象\n\n**在 es6 到来之前，网上流传了多个版本的使用 es3 实现类和继承，其中最为出名的就是基于原型的继承方式。**\n\n**在 es6 中引入 Class 关键字，这简直太棒了，避免了各个公司或插件实现的继承不同而造成阅读代码困难的问题，并且 Class 使用起来相对方便。**\n\n**但是 Class 暂时还没有私有变量的概念，不像其他的后端语言。**","tags":["js"]},{"title":"js 小技巧","url":"/blog/2019/03/06/js-skill/","content":"\n### 一、js 重载\n\n**众所周知，js 中没有重载概念，但可以利用代码来实现重载。**\n\n``` js\nfunction addMethod(obj, name, fn) {\n    let oldFn = obj[name];\n\n    obj[name] = function (...arg) {\n        arg.length === fn.length? fn(...arg): oldFn(...arg);\n    }\n}\n\nlet jqx = {};\naddMethod(jqx, 'say', () => {console.log(0)});\naddMethod(jqx, 'say', (a) => {console.log(1)});\naddMethod(jqx, 'say', (a, b) => {console.log(2)});\n\njqx.say();\njqx.say('a');\njqx.say('a', 'b');\n```\n\n**如果怕调用栈太深，也可以借助 map 对象把 arg.length 和 函数对应起来。**\n\n### 二、优化 switch\n\n**有些情况下，需同时判断多个条件，写 if-else 和 switch 会使函数看起来相当庞大，不妨试试 map。**\n\n``` js\nlet classical = new Map();\nclassical.set(20, '弱冠');\nclassical.set(30, '而立');\nclassical.set(40, '不惑');\nclassical.set(50, '知天命');\nclassical.set(60, '花甲子');\nclassical.set(70, '古来稀');\nclassical.set(80, '耄耋之年');\n\nfunction age2classical(age) {\n    return classical.get(age);\n}\n\nage2range(20); // 弱冠\nage2range(25); // undefined\nage2range(40); // 不惑\n```\n\n### 三、一行获取数组的交集、并集、差集\n\n``` js\nlet a = [1, 2, 3];\nlet b = [3, 4, 5];\n\na.filter(item => b.includes(item)); // 交集\n[...new Set([...a, ...b])]; // 并集\n[...new Set([...a, ...b])].filter(item => !(a.includes(item) && b.includes(item))); // 差集\n```","tags":["js"]},{"title":"jquery 技术内幕","url":"/blog/2019/03/04/jquery-technology-insider/","content":"\n<script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"></script>\n\n**记录前端鼻祖 ———— jquery 的 js 技巧**\n\n### 一、jquery 对象\n\n**在没有 es6 的 Class 之前，js 中都使用 function 以及他的 propotype 来实现面向对象。但是尽管如此，总有人在初始化实例时，忘记加上 new 关键字，这就会造成意外的全局污染。**\n\n``` js\nfunction Person(name) {\n    this.name = name;\n}\n\n// 正常使用\nvar man = new Person('老王');\nconsole.log(man.name); // 打印 老王\n\n// 忘记带 new\nvar man = Person('老王');\nconsole.log(window.name); // window 添加了一个变量 name\n```\n\n**这就会在你不知情的情况下，定义了一个全局变量。而 jquery 在生成新对象的时候，从来都没有带上 new 关键字，jquery 在创建对象时使用了一个技巧。**\n\n``` js\nfunction Person(name) {\n    this.name = name;\n}\n\nfunction createPerson(name) {\n    return new Person(name);\n}\n\nvar man = new createPerson('老王');\nvar woman = createPerson('小丽');\n\nconsole.log(man.name); // 打印 老王\nconsole.log(woman.name); // 打印 小丽\nconsole.log(man.prototype === woman.prototype); // 打印 true\n```\n\n**使用 new 关键字后，如果函数 return 了一个对象，返回对象，若返回的不是对象则创建一个新对象返回。**\n\n**在 createPerson 函数返回了一个 new Preson，使得即使不使用 new 关键字也可以创建对象实例，既保证创建对象时的安全，也方便调用。**\n\n**源码中的代码：**\n\n![jquery_init](../../../../img/jquery_technology_insider/jquery_init.png)\n\n### 二、jquery 原型\n\n**在使用 jquery 的插件时，在 $.fn 上扩展方法，对象 $() 上就能访问刚刚挂载的方法。**\n\n``` js\n$.fn.log123 = function () {\n    console.log(123)\n}\n\n$().log123() // 打印 123\n```\n\n**再结合上面返回的 $.fn.init 实例，可见 $.fn 就是 $.fn.init.prototype。的确在源码中也做了这样的定义，使得返回的对象可以拿到原型上的方法。**\n\n![jquery_init_propotype](../../../../img/jquery_technology_insider/jquery_init_propotype.png)\n\n**再附上一张 jquery 非常绕的原型图：**\n\n![jquery_propotype](../../../../img/jquery_technology_insider/jquery_propotype.png)\n\n### 三、类型判断\n\n**在判断一个对象是 json 还是 array 的时候，公认的有效的方法是使用 Object.prototype.toString.call( Obj )。对于得到的字符串还要进行 slice 才能拿到对象真正的类型。**\n\n**在 jquery 中，建立了一个 map 来获取对象的类型。**\n\n``` js\nconst class2type = {};\n\n\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ).forEach(name => {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n})\n\n/*\n* 得到\n* {\n*   \"[object Boolean]\": \"boolean\",\n*   \"[object Number]\": \"number\",\n*   \"[object String]\": \"string\",\n*   \"[object Function]\": \"function\",\n*   \"[object Array]\": \"array\",\n*   \"[object Date]\": \"date\",\n*   \"[object RegExp]\": \"regexp\",\n*   \"[object Object]\": \"object\",\n*   \"[object Error]\": \"error\",\n*   \"[object Symbol]\": \"symbol\"\n* }\n*/  \n\nconst toString = class2type.toString;\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n```\n\n### 四、绑定事件\n\n**jQuery 的绑定事件不仅可以给元素绑，还可以给对象绑，还可以根据参数来判断是否进行事件委托，还可以绑定自定义的事件，多才多艺的一个成员。他会在绑定的时候将需要触发的事件绑定在对象的一个属性上，保存在内存中。**\n\n``` js\njQuery.event.add = function(elem, types, handler, data, selector) {\n    var // 省略一堆属性\n        elemData = dataPriv.get(elem); // 在获取将要绑定的元素的 jQuery.expando（这个值为一个jQuery开头的唯一字符串） 属性，若不存在这属性则赋值为空对象\n    // Make sure that the handler has a unique ID, used to find/remove it later\n    if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n    }\n\n    // 将事件函数推入内存中\n    // Init the element's event structure and main handler, if this is the first\n    if (!(events = elemData.events)) {\n        events = elemData.events = {};\n    }\n    if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function(e) {\n\n            // Discard the second event of a jQuery.event.trigger() and\n            // when an event is called after a page has unloaded\n            return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n        };\n    }\n\n    handleObj = jQuery.extend({\n        type: type,\n        origType: origType,\n        data: data,\n        handler: handler,\n        guid: handler.guid,\n        selector: selector,\n        needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n        namespace: namespaces.join(\".\")\n    }, handleObjIn);\n\n    // Init the event handler queue if we're the first\n    if (!(handlers = events[type])) {\n        handlers = events[type] = [];\n        handlers.delegateCount = 0;\n\n        // Only use addEventListener if the special events handler returns false\n        if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n\n            if (elem.addEventListener) {\n                elem.addEventListener(type, eventHandle);\n            }\n        }\n    }\n\n    // Add to the element's handler list, delegates in front\n    if (selector) {\n        handlers.splice(handlers.delegateCount++, 0, handleObj);\n    } else {\n        handlers.push(handleObj);\n    }\n}\n\n```\n\n**推入后，可以在绑定事件的对象属性中看到事件队列。**\n\n![jquery_eventHandle](../../../../img/jquery_technology_insider/event_handle.png)\n\n**其中比较有意思的就是 namespace 了，在触发和删除事件的时候会用到，下面是触发事件的函数。**\n\n``` js\njQuery.extend(jQuery.event, {\n\n    // 封装 event 对象，绑上 isTrigger, namespace等属性\n    trigger: function(event, data, elem, onlyHandlers) {\n        var //定义一堆变量\n\n        cur = lastElement = tmp = elem = elem || document; // 触发事件的对象\n\n        if (type.indexOf(\".\") > -1) {\n\n            // Namespaced trigger; create a regexp to match event type in handle()\n            namespaces = type.split(\".\");\n            type = namespaces.shift();\n            namespaces.sort();\n        }\n\n        // Caller can pass in a jQuery.Event object, Object, or just an event type string\n        event = event[jQuery.expando] ? event : new jQuery.Event(type,typeof event === \"object\" && event);\n\n        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n        event.isTrigger = onlyHandlers ? 2 : 3; // 使用 trigger 函数触发时，onlyHandlers为 undefined\n        event.namespace = namespaces.join(\".\");\n        event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // 生成 命名空间正则\n\n        handle = (dataPriv.get(cur, \"events\") || {})[event.type] && dataPriv.get(cur, \"handle\");\n        if (handle) {\n            handle.apply(cur, data); // 触发了add时候绑定的函数，走到了 jQuery.event.dispatch\n        }\n    }\n}\n\njQuery.event.dispatch = function(nativeEvent) {\n    var handlers = (dataPriv.get(this, \"events\") || {})[event.type] || []; // 从缓存中获取绑定的事件\n\n    // Determine handlers\n    handlerQueue = jQuery.event.handlers.call(this, event, handlers);\n\n    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) { // 遍历事件队列\n        event.currentTarget = matched.elem;\n\n        j = 0;\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n\n            // Triggered event must either 1) have no namespace, or 2) have namespace(s)\n            // a subset or equal to those in the bound event (both can have no namespace).\n            if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) { // 正则add时存下的handle对象的namespace属性，若匹配上则触发\n\n                event.handleObj = handleObj;\n                event.data = handleObj.data;\n\n                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n                if (ret !== undefined) {\n                    if ((event.result = ret) === false) {\n                        event.preventDefault();\n                        event.stopPropagation();\n                    }\n                }\n            }\n        }\n    }\n}\n```","tags":["jquery"]},{"title":"css 矩阵和 tramsform 之间换算","url":"/blog/2019/03/03/css-matrix/","content":"\n**在学数学时，同学们总在一起打趣：学这么多的函数运算有什么用，以后买菜总不能先列一个函数，算出该付多少钱吧。可谁知，在科技高速发展的时代，打趣的话也快要“实现”了。**\n**在 css3 中，退出了新属性——— matrix(矩阵)，这不正是大一时候学的线性代数吗（好在大一的时候还不是很皮，都认真听讲了）**\n\n### 一、矩阵计算\n\n**css3 中的 matrix 用来代替多个 transfrom 属性或者一些 transfrom 无法实现的效果，就来看一看 matrix 是怎么实现变换的吧。**\n\n**首先来看一下矩阵的参数：**\n``` js\ntransform: matrix(a,b,c,d,e,f);\n```\n\n**这6个参数提供了一个 3 * 3 的矩阵，而经过这个矩阵能够计算出变换前的 x，y 值与变换后的 x，y 值的关系。反应式如下：**\n\n![matrix](../../../../img/css-matrix/matrix.gif)\n\n**其中 x，y 为变化前的坐标，ax+cy+e 为变换后的 x'，bx+dy+f 表示变换后的 y'。**\n**举个例子，如果我们有一个矩形有 A(0, 0) B(200, 0) C(0, 100) D(200, 100) 四个点组成，经过矩阵转换后，我们希望得到如下变换：**\n\n![transfrom](../../../../img/css-matrix/transfrom.png)\n\n**在 css 中，坐标轴的零点都是左上角，x 轴和 y 轴的方向也与数学中的坐标轴有所不同。也就是我们需要得到的矩阵坐标为 A'(300, 100) B'(300, 300) C'(400, 100) D'(400, 300)，那么就可以根据公式 ax+cy+e=x'，bx+dy+f=y' 算出 a,b,c,d,e,f 各为多少。**\n\n``` js\n// 将 A(0, 0) 和 A'(300, 100) 两点带入 ax+cy+e=x' bx+dy+f=y'\na * 0 + c * 0 + e = 300;\nb * 0 + d * 0 + f = 100;\n\ne = 300;\nf = 100;\n\n// 以此类推，将四个点全部带入计算得出 a,b,c,d,e,f 四个值\n// 此例中为 \ntransform: matrix(0, 1, 1, 0, 300, 100);\n```\n\n**最终矩阵变换的效果图如下**\n\n<iframe src=\"https://howgraceu.github.io/demo/matrix/\" style=\"margin-left: -2em; width: 100%; height: 225px;\"><iframe>\n\n### 二、matrix 与 transfrom 各个属性的转换。\n\n**transfrom 的各个属性能够与 matrix 相互转换。**\n\n``` css\n/* matrix 默认值 */\ntransform: matrix(1, 0, 0, 1, 0, 0);\n\n/* translate */\ntransform: translate(x, y);\ntransform: matrix(0, 0, 0, 0, x, y);\n\n/* scale */\ntransform: scale(x, y);\ntransform: matrix(x, 0 * x, 0 * y, y, 0, 0);\n\n/* rotate */\nrotate: rotate(θ);\ntransform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0);\n```\n\n**张鑫旭大神的博客[理解CSS3 transform中的Matrix](https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/) 一文对此有详细的解释。**\n\n**但是需要注意的是，当 scale 和 rotate 一起使用的时候，两者的值需要相乘。**\n\n``` css\n/* scale 2 */\ntransform: scale(x, y);\nrotate: rotate(θ);\n\ntransform: matrix(cosθ * x, sinθ * x, -sinθ * y, cosθ * y, 0, 0);\n```\n\n### 三、matrix 与 transfrom 转换函数。\n\n**根据 matrix 与 transfrom 之间的关系，可以提出一个函数来进行两者之间的转换（转换顺序为先 transfrom 再 rotate）。**\n\n``` js\nconst PI = Math.PI;\n\nfunction encodeMatrix({translateX = 0, translateY = 0, rotate=0, scaleX=1, scaleY=1} = {}) {\n    let rad = rotate * PI / 180;\n    let a = scaleX * Math.cos(rad);\n    let b = scaleX * Math.sin(rad);\n    let c = scaleY * -Math.sin(rad);\n    let d = scaleY * Math.cos(rad);\n    let e = translateX;\n    let f = translateY;\n\n    return [a,b,c,d,e,f]\n}\n\nfunction decodeMatrix([a = 1, b = 0, c = 0, d = 1, e = 0, f = 0] = []) {\n    let translateX = e;\n    let translateY = f;\n    let scaleX = Math.round(Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)));\n    let scaleY = Math.round(Math.sqrt(Math.pow(c, 2) + Math.pow(d, 2)));\n    let radC = Math.acos(a / scaleX);\n    let radS = Math.asin(b / scaleX);\n\n    let rad\n    if (b >= 0) {\n        rad = radC;\n    } else if (b < 0) {\n        rad = 2 * PI - radC;\n    }\n\n    let rotate = Math.round(rad * 180 / Math.PI);\n\n    return {translateX, translateY, rotate, scaleX, scaleY}\n}\n\nlet matrix = encodeMatrix({translateX: 30, translateY: 40, rotate: 45, scaleX: 2, scaleY: 3});\n//  [1.4142135623730951, 1.414213562373095, -2.1213203435596424, 2.121320343559643, 30, 40]\n\nlet transfrom = decodeMatrix([1.4142135623730951, 1.414213562373095, -2.1213203435596424, 2.121320343559643, 30, 40]);\n// {translateX: 30, translateY: 40, rotate: 45, scaleX: 2, scaleY: 3}\n```\n\n**上述函数在自己写的一个 [svg-editor](https://howgraceu.github.io/demo/svg/) 的例子中使用，但是在使用过程中发现如果缩放倍数不为整数时，可能会得到不精确的结果，导致最后结果偏差较大。**\n\n**最后附上一个用于转化 transfrom 和 matrix 的网页，[meyerweb-matrix](https://meyerweb.com/eric/tools/matrix/)**","tags":["matrix"]},{"title":"粗读 Concurrent.Thread.js 源码","url":"/blog/2019/02/28/concurrent_thread_read/","content":"\n**最近看到了一个帮助没有 Worker 的浏览器开启多进程处理的 js 库 ———— [Concurrent.Thread.js](https://github.com/HowGraceU/Concurrent.Thread.js)。**\n**这个库使古老的单进程的 js 拥有了多进程的能力，这瞬间使我产生了浓厚的兴趣，于是决定去探究一下这个 js 到底是怎么执行的。**\n\n### 一、断点进入 create 函数查看\n\n**最直接的方法便是通过断点，进入改 js 的起点，一步一步得深入。**\n\n![debug1](../../../../img/concurrent_thread_read/debug1.png)\n\n**concurrentJs 似乎将传入的函数解析成立 AST**\n\n![debug2](../../../../img/concurrent_thread_read/debug2.png)\n\n**由于之后的代码看得一脸蒙，决定换一种方法去探究该 js**\n\n### 二、查看 devtool performace\n\n**谷歌浏览器提供了 performace 用来抓页面的一段时间内 js 的运行情况和页面渲染的情况，这里也可以用这个工具来监听一下 concurrentJs 的运行情况。**\n\n![performace1](../../../../img/concurrent_thread_read/performace1.png)\n\n**从图中可以看出，js 的运行情况似乎是一个循环，图中蓝色部分是 Parse HTML，紫色部分是 Layout，而蓝色框框框中的部分，是一个 timeout 定时器。**\n**点击 timeout 部分可以定位到源码行。**\n\n![performace2](../../../../img/concurrent_thread_read/performace2.png)\n\n**粗读源码发现，concurrentJs 将 js 解析成了多个 timeout，以此达到多进程的效果，让 js 不堵死主进程的效果。**","tags":["multiprocess"]},{"title":"跨域资源共享的10种方法","url":"/blog/2019/02/24/cross-domain-methiod/","content":"\n**最近学习过程中，听到（还是看到）有人说，看懂了不是真的会。看懂了，记下来并能够把别人讲懂才是真的会。**\n**看完之后感触颇深，决定将之后学习全部做一个记录，来检验自己是否理解细节。今天就从老生常谈的跨域方法开始。**\n\n### 1. img 标签跨域\n\n**并非 img 标签，所有的带属性 src 可以请求到不同源的资源，并且可以在url里面加上queryString向后台发送数据。**\n\n``` js\n// URL末尾带上了 ?name=jqx，传了name字段到后台\n<img  crossOrigin=\"anonymous\" id=\"tulip\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=489343535,3713603063&fm=58?name=jqx\" alt=\"The Tulip\" />\n```\n\n### 2. img 标签跨域\n\n**为什么第二个还是 img 标签跨域？是不是作者糊涂了？其实不然。**\n\n**图片和 base64 之间可以相互转换，所以就有人往上面动歪脑筋了，想出了花里胡哨（sang xin bing kuang）的办法。将数据放在图片里面，前端拿到图片之后，利用 canvas 可以拿到图片的 base64 数据。**\n\n**注意：跨域的图片想要利用 canvas 转成 base64 数据，需要在img和后台添加跨域支持（与 ajax 跨域类似）**\n\n``` js\n<img  crossOrigin=\"anonymous\" id=\"tulip\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=489343535,3713603063&fm=58?name=jqx\"/>\n\n<canvas id=\"myCanvas\"></canvas>\n\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\nvar img=document.getElementById(\"tulip\");\n\nctx.drawImage(img, 10, 10);\nconsole.log(myCanvas.toDataURL());\n```\n\n### 3. jsonp 跨域\n\n**jsonp 跨域的道理与 img 方法有相同，也有不同的地方。**\n\n**相同的地方是，利用 script 标签的 src 属性，将自己定义好的回调函数传给后台，与 img 一样发起一个 GET 请求。**\n\n**不相同的是，img 标签拿到返回的数据之后会渲染图片，而 script 标签拿到返回数据之后，会运行返回的 js 代码，而代码的内容，就全权交由后台掌控了。**\n\n### 4. document.domain 跨 cookie\n\n**在跨域情况下，各个网页的 cookie 是无法共享的，但是如果两者的一级域名（至少是一级域名）相同的情况下，通过设置 cookie 的 domain 使得两个网页的 cookie 数据是可以共享的。**\n\n**正常情况下的 cookie**\n![domain1](../../../../img/cross-domain-methiod/domain1.png)\n\n**设置了 domain 的cookie**\n![domain2](../../../../img/cross-domain-methiod/domain2.png)\n\n``` js\n// www.baidu.com\ndocument.cookie = 'name=jqx;domain=.baidu.com'\n\n// news.baidu.com\ndocument.cookie\n// name=jqx;\n```\n\n**不过一般情况下，都会从后台来控住 cookie domain 值**\n\n``` js\nSet-Cookie: name=jqx; domain=.baidu.com\n```\n\n### 5. 父子页面 location.hash\n\n**针对使用 iframe 或者 window.open 打开了不同源的网页，两者之间不能进行访问的情况。**\n\n**在提前知道对方的url的情况下，父子页面可以相互修改 hash 值来进行传值。**\n\n``` js\n// iframe 打开子页面\n// 父页面  http://192.168.0.112:8000/A.html\n<iframe id=\"myIframe\" name=\"myIframe\" src=\"http://192.168.0.112:8002/B.html\" frameborder=\"0\"></iframe>\n\nlet myIframe = document.getElementById('myIframe');\nmyIframe.src = `${myIframe.src}#jqx`\n\n// 子页面 http://192.168.0.112:8002/B.html\n// 因无法访问父页面，所以需先知道父页面的 url\nlet parentUrl = 'http://192.168.0.112:8000/A.html';\nparent.location.href = `${parentUrl}#jqx`\n\n// 使用 window.open 方式打开子页面\n// 父页面  http://192.168.0.112:8000/A.html\nlet childUrl = 'http://192.168.0.112:8002/B.html';\nlet childWindow = window.open(childUrl);\nchildWindow.location.href = `${childUrl}#jqx`\n\n// 子页面 http://192.168.0.112:8002/B.html\nlet parentUrl = 'http://192.168.0.112:8000/A.html';\nwindwo.opener.location.href = `${parentUrl}#jqx`\n```\n\n### 6. 父子页面 window.name\n**window.name 属性，只要在用一窗口里，前一个网页设置了这个属性，后一个网页也可以读取他。**\n\n**当父页面打开不同源的子页面，子页面可以将数据转成字符串存在 window.name 属性中，存完后再使用 location.herf 跳转到与父同源的页面，父页面就可以通过子页面的 window.name 属性拿到数据。**\n\n**这种方法局限性很大，无法及时得知子页面的 name 的变化（无监听API），且子页面返回一次数据后页面就被销毁。**\n\n### 7. 父子页面 window.postMessage\n**H5 提供了新 [postMessage API](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) 来帮助不同源的父子页面进行更方便的交互。**\n\n``` js\n// iframe 打开子页面\n// 父页面  http://192.168.0.112:8000/A.html\n<iframe id=\"myIframe\" name=\"myIframe\" src=\"http://192.168.0.112:8002/B.html\" frameborder=\"0\"></iframe>\n\nlet myIframe = document.getElementById('myIframe');\nmyIframe.addEventListener('load', () => {\n    myIframe.contentWindow.postMessage({a: 1}, 'http://192.168.0.112:8002');\n})\n\nwindow.addEventListener('message', e => {\n    console.log(`B data: ${e.data}`);\n})\n\n// 子页面 http://192.168.0.112:8002/B.html\nwindow.addEventListener('message', (e) => {\n    let {origin, data, source} = e;\n    console.log(`message from : ${origin}`);\n    console.log(`data : ${JSON.stringify(data)}`);\n    source.postMessage('receive', 'http://192.168.0.112:8000');\n}, false)\n```\n\n**输出**\n![postMessage](../../../../img/cross-domain-methiod/postMessage.png)\n\n**其中 postMessage 方法第一个参数代表需要传输的数据，第二个方法代表希望传输的目标源。**\n\n**目标页面在 window 上绑定 message 事件后，待父页面发送数据触发页面。event 对象中有代表数据来源的 origin，代表数据的 data，代表来源 window 的 source。可以通过 source 通道反向传数据。**\n\n### 8. form表单跨域\n**form 表单的提交是没有跨域限制的，因为表单的提交之后没法在不同源的页面拿到返回的数据，所以浏览器认为这是相对安全的请求。**\n\n**BTW，所有的跨域请求其实都返回了，只是浏览器限制了 js 获取响应，所以导致了跨域问题。**\n\n**form 表单可以跨域提交，并且将返回的数据写入指定的 iframe 中，再利用 iframe 之间的资源共享方案（5，6，7），还是有办法拿到数据的。**\n\n``` js\n<form name=\"login\" action=\"http://192.168.0.112:3000/login\" method=\"POST\" enctype=\"multipart/form-data\" target=\"login-iframe\">\n    <label for=\"name\">name</label>\n    <input name=\"name\" type=\"text\" value=\"jqx\">\n    <label for=\"password\">password</label>\n    <input name=\"password\" type=\"password\" value=\"12345678\">\n    <button>提交</button>\n</form>\n\n<iframe name=\"login-iframe\" src=\"\" frameborder=\"0\" width=\"500\" height=\"500\"></iframe>\n```\n\n![form提交](../../../../img/cross-domain-methiod/form.png)\n\n### 9. CORS\n**主流的跨源资源分享解决方法。**\n\n**使用 ajax 请求不同源页面资源，可以直接操作返回的数据，需要后台添加请求头。[CORS MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)描述得非常详细。**\n\n**需要注意的是，CORS 有简单请求和非简单请求之分，而非简单请求时，会先向后台发送一个 OPTION 请求，之前还碰到非简单请求的坑。猛戳[博客](../../../../2018/08/29/axios-CORS/)**\n\n### 10. WebSocket\n**WebSocket 是一个新协议，实现了客户端和服务端之间的全双工、实时、并发交互数据。**\n\n**因为是一个全新的协议，所以浏览器在请求数据的时候就已经跨域了。服务端能通过请求头里面的 origin 字段来判断浏览器是否在白名单。**\n\n**以上全个人见解**","tags":["cross-domain"]},{"title":"array的长度大于10时，sort的行为","url":"/blog/2018/10/25/arrSort/","content":"\n### 一、函数返回布尔时，排序不正常\n\n**同事说遇到了一个奇怪的bug，找我一起看，他的代码**\n\n``` js\nvar arr = [1,3,2,4,5,8,6,9,11,7,0];\n\narr.sort((a, b) => a > b);\n// [8, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11]\n```\n\n**wft！这有点颠覆我对js的认识啊，于是自己进行了测试，发现怎么测试结果都是正常的从小到大排序**\n\n**仔细查阅了mdn文档以及网上的资料发现，例子中的返回值都是以大于0，小于0和0来区别，并且数组长度大于10和小于等于10时，处理方法不一样。在大于10时，浏览器使用了一种快排的方法对数组进行排序，小于10时则是冒泡排序。**\n\n### 二、快排时会出现问题\n\n**于是进行进一步测试，当数组长度大于10时，果然数组的排序不尽如人意。似乎是快排的时候出了问题，于是翻了一下[github上V8项目中快排的代码](https://github.com/v8/v8/blob/master/src/js/array.js)，发现代码中的使用了 >= 来判断是否需要交换位置。所以返回false会使得if成立，而返回小于0则不会。**\n\n![V8快排](../../../../img/arrSort/V8QS.png)\n\n**综上，在sort的函数中，始终返回数值类型而不返回布尔类型就可以避免出现bug。**\n\n### 浏览器新版本支持度\n\n**顺便一提，测试时发现，在新版本的谷歌之中（70）和edge（17），不会处理返回布尔类型的情况。不管是冒泡还是快排。**\n``` js\nvar arr = [1,3,2,4,5,8,6,9];\n\narr.sort(function(a, b) {return a > b});\n// [1, 3, 2, 4, 5, 8, 6, 9]\n```\n\n### 三、快排算法\n\n**最后附上阮大大的对[快排](http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html)算法详细解释的文章**","tags":["v8"]},{"title":"node 循环引用","url":"/blog/2018/09/14/node-cyclic/","content":"\n**近期在node开发的过程中，碰到require文件后，无法调用文件内定义的方法，翻阅资料怀疑是循环引用，于是自己进行了测试。**\n\n## 一、循环引用测试\n\n**a.js**\n``` js\nconsole.log('at a.js');\nvar b = require('./b');\n\nexports.test = \"i'm a\";\n\nsetImmediate(() => {\n    console.log(`get b.test ${b.test}`);\n})\n```\n\n**b.js**\n``` js\nconsole.log('at b.js');\nvar a = require('./a');\n\nmodule.exports = {\n    test: \"i'm b\"\n}\n\nsetImmediate(() => {\n    console.log(`get a.test ${a.test}`);\n})\n```\n\n**测试结果如下**\n``` js\nnode .\\a.js\n\nat a.js\nat b.js\nget a.test i'm a\nget b.test i'm b\n\nnode .\\b.js\n\nat b.js\nat a.js\nget b.test undefined\nget a.test i'm a\n```\n\n**运行b.js的时候，当运行到 require('./a') 的时候，去加载a.js的代码，而a.js里又 require('./b')，这里导致了循环引用。**\n\n**但是这里并不会进入死循环，原因是node在require的时候发现内存里已经存在这个模块的引用，则返回引用而不会重新去运行这个模块的代码。**\n\n**node .\\a.js的时候，require('./b')，而a.js停留在 var b = require('./b');，此时在b.js 得到的a模块的内容为a的module.exports {}。在运行完b.js之后，又在a的module.exports对象上加上属性，所以b中延迟打印出来的a的属性存在。**\n\n**而node .\\b.js的时候，require('./a')，b.js停留在var a = require('./a');，此时还没有运行module.exports = { test: \"i'm b\" }，得到b模块的内容为b的module.exports {}，运行完a之后，执行 module.exports = ... 代码，将module.exports指向了另一个对象，而缓存中b模块的内容则是之前引用的b的module.exports，所以b的test属性并没有加在b模块在内存中的对象上，所以之后再有require('./b')拿到的都是空对象 {}**\n\n## 二、避免循环引用产生的问题\n\n*   尽量不使用module.exports重置模块的引用。\n*   非要使用module.exports，module.exports应该放在js的开头，即其他逻辑之前。\n\n### 题外：在查node循环引用问题时，看到一个知名搜索引擎上较为靠前的博客有点问题。\n\n**以下为文中的测试代码**\n``` js\na.js\n\nconsole.log('a.js');\nvar b = require('./b');\nconsole.log('a+.js');\nconsole.log(b);\nexports={name:'a'};\nconsole.log('a++.js');\n\n\nb.js\n\nconsole.log('b.js');\nvar c = require('./a');\nconsole.log('b+.js');\nconsole.log(c);\nexports={name:'b'};\nconsole.log('b++.js');\n```\n\n**测试结果中，模块a和模块b都是 {}**\n**这个代码不管怎么改，打印出来的结果都是 {}，因为在node中 exports={name:'a'}; 无法用来暴露变量。原因如下**\n\n``` js\n(function (exports, require, module, __filenam, __dirname) {\n    ...文件中代码\n})\n```\n**代码来自《深入浅出nodejs》，上述代码的是在每一次用node运行js脚本的时候，都会运行上述函数来执行脚本中的代码，而脚本中使用的exports、module都只是这个函数中的一个局部变量。当你运行 exports={name:'a'}; 时，不过改变这个函数作用域中，局部变量的指向，而非改变 module.exports 所指向的对象中的属性。**","tags":["moudle"]},{"title":"axios跨域请求报错","url":"/blog/2018/08/29/axios-CORS/","content":"\n**在一个开发web桌面应用的项目中，使用了axios向服务器发送请求，结果报了跨域请求的错误。页面代码大致如下：**\n\n``` js\n<script src=\"./node_modules/axios/dist/axios.js\"></script>\n<script>\n        axios.post('http://127.0.0.1:3000/getDate', {\n            a: 1\n        });\n</script>\n```\n\n![跨域报错](../../../../img/axios-CORS/1.png)\n\n**反复查看后台代码，明明是已经加上了跨域的头部Access-Control-Allow-Origin，可是还是请求失败。**\n\n**代码倒是看不出任何问题，于是猜想是axios内部框架做了什么鬼祟，使用原生的XHR对象进行调试。**\n\n![原生XHR跨域](../../../../img/axios-CORS/2.png)\n\n**果然请求到了，并且看到返回头里面带上了允许跨域头。仔细比对两次请求发现，axios发的请求的method竟是OPTIONS，这是什么，html难道不是只有GET，POST吗！？翻查[http mdn](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)**\n\n## 一、xhr跨域请求\n\n**出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。以下三种情况下跨域请求的结果皆不相同。**\n\n### 二、简单请求\n\n**某些请求不会触发 CORS 预检请求。若请求满足所有下述条件，则该请求可视为“简单请求”：**\n\n*   **使用下列方法之一：**\n    *   GET\n    *   HEAD\n    *   POST\n*   **Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：**\n    *   Accept\n    *   Accept-Language\n    *   Content-Language\n    *   Content-Type （需要注意额外的限制）\n    *   DPR\n    *   Downlink\n    *   Save-Data\n    *   Viewport-Width\n    *   Width\n*   **Content-Type 的值仅限于下列三者之一：**\n    *   text/plain\n    *   multipart/form-data\n    *   application/x-www-form-urlencoded\n*   **请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。（文件上传对象）**\n*   **请求中没有使用 ReadableStream 对象。**\n\n### 三、预检请求\n**简单来说，请求不满足简单请求规范，则为预检请求。预检请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。**\n\n**从文章开头的例子中可以看出我们的OPTIONS是一个预检请求，应该是由axios发送跨域请求的时候进行了头部的设置导致。从OPSTIONS的抓包上看，请求头里面倒是有需要预检的首部字段。**\n\n```\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Content-Type \n\n// 服务器端应加上\nAccess-Control-Allow-Methods: POST //简单请求允许method，可不带\nAccess-Control-Allow-Headers: Content-Type\n```\n\n**看来是axios将请求头进行了设置导致跨域失败，进入axios源码查看，哪里进行了配置。进入源码查询发现axios在参数为json对象时，设置了content-type为application/json;charset=utf-8**\n\n![axios源码](../../../../img/axios-CORS/3.png)\n\n### 四、解决方案一：修改请求头\n\n**一种解决方法是axios设置默认头部**\n\n``` js\n<script src=\"./node_modules/axios/dist/axios.js\"></script>\n<script>\n        let config = {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            }\n        };\n\n        axios.post('http://127.0.0.1:3000/getDate', {\n            a: 1\n        }, config);\n</script>\n```\n\n### 五、解决方案二：服务端添加预检支持\n\n**这毕竟是一个跨域资源，是多人共享的资源，不能保证每个人请求头都属于简单请求，所以应该在服务器端对预检请求添加支持。**\n\n``` js\n// 这里以koa为例\nconst Koa = require('koa');\nconst Router = require('koa-router');\n\nconst app = new Koa();\nvar router = new Router();\n\nrouter\n  .get('/', (ctx, next) => {\n    ctx.body = 'Hello World!';\n  })\n  .post('/getDate', (ctx, next) => {\n    ctx.set('Access-Control-Allow-Origin', '*');\n    ctx.set('Access-Control-Allow-Headers', 'Content-Type');\n    ctx.response.type = 'json';\n    ctx.response.body = { data: 'Hello World' };\n  })\n\napp\n  .use(router.routes())\n  .listen(3000);\n```\n\n**加上响应头之后，理应能够自定义content-type的值，且成功跨域才对。可是跑最开始的跨域请求却出现404**\n\n![OPTIONS请求404](../../../../img/axios-CORS/4.png)\n\n**竟然是404，一顿推理，妄加猜测，应是服务器没有路径为/getDate，method 为 OPTIONS 的路由，在服务器端加上路由。**\n\n``` js\nrouter\n  .options('/getDate', (ctx, next) => {\n    ctx.set('Access-Control-Allow-Origin', '*');\n    ctx.set('Access-Control-Allow-Headers', 'Content-Type');\n    ctx.response.body = 'allow';\n  })\n```\n\n**加上后自定义头部的跨域请求也可以正常跨域了**\n\n![预检请求OPTOINS](../../../../img/axios-CORS/5.png)\n\n![预检请求POST](../../../../img/axios-CORS/6.png)\n\n**由上面2图可以看出，预检跨域请求，浏览器会发送2个请求到服务器端，一个是OPTIONS预检，一个是POST请求，产生2条抓包。**\n\n</br>\n### 六、题外：跨域资源共享标准 （有些不常用，mark一下）\n\n**跨域资源共享标准（ [cross-origin sharing standard](http://www.w3.org/TR/cors/) ）允许在下列场景中使用跨域 HTTP 请求：**\n\n*   **XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。**\n*   **Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。**\n*   **WebGL 贴图**\n*   **使用 drawImage 将 Images/video 画面绘制到 canvas**\n*   **样式表（使用 CSSOM）**\n*   **Scripts (未处理的异常)**","tags":["CORS"]},{"title":"hello world","url":"/blog/2018/08/28/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["blogTest"]},{"title":"常见的内存泄露和排查","url":"/blog/2018/08/23/leak&debugger/","content":"# 一、内存泄露\n\n## 什么是内存泄露\n\n本质上来讲，内存泄露是当一块内存不再被应用程序使用的时候，由于某种原因没有返还给操作系统或者空闲内存池的现象。\n\n## js的内存管理\n\njs中的垃圾回收机制，会周期性地检查之前被分配出去的内存是否可以从应用的其他部分访问。换句话说，什么样的内存仍然可以从应用程序的其他部分访问，不可访问的内存可以通过算法确定并标记以便返还给操作系统。\n\n# 二、常见4种的内存泄露\n\n1.  意外的全局变量\n\n``` js\n/* 例子1 */ \nfunction foo () {\n    bar = 'a hidden global variable';\n}\n\n/* 例子2 */ \nfunction foo () {\n    this.bar = 'a global variable';\n}\n\nfoo()\n```\n\n##### 全局变量注意事项\n\n如果你必须使用全局变量来存储很多的数据，请确保在使用过后将它设置为null。\n\n2.  监听\n\n``` js\nvar el = ducumemt.getElementById('a');\n\nvar onClick = () => {\n    el.innerText = 'text';\n}\n\nel.addEventListener('click', onClick);\n\nel.removeEventListener('click', onClick);\nel.parentNode.removeChild(el);\n```\n\ndom节点和js代码之间的循环引用，在ie老版本上会有内存泄露bug。大部分类库在废弃一个节点之前，会移除listener。目前，现代浏览器（包括IE）都能发现这些循环引用并正确回收，在废弃一个节点之前调用removeEventListener不再是必要的操作。\n\n3.  DOM引用\n\n``` js\n<div id='a'>\n    <div id='b'></div>\n<div>\n\nvar divB = document.getElementById('b');\ndocument.body.removeChild(document.getElementById('a'));\n```\n\njs代码中保留了子元素的特定引用，然后移除父辈元素div#a，表面上看整个元素都被移除了，但是在内存中还保留着对div#a的引用。因为div#b保留着对父辈的引用，导致整个div#a都保留在内存中。\n\n4.  闭包\n\n``` js\n/* 代码一 */ \nvar obj = null;\nvar replaceObj = () => {\n    var oldObj = obj;\n    obj = {\n        memory: new Array(1000000).join('*'),\n        closeFn () {\n            console.log(123);\n        }\n    };\n    oldObj && oldObj.closeFn();\n}\n\nsetInterval(replaceObj, 1000);\n```\n上述代码调用结果如下图\n\n![无闭包时函数调用](../../../../img/leak&debugger/1.jpg)\n\n断点进函数查看，并没有闭包引用，并且打印稳定1秒钟1个\n\n正常时候的内存情况为下图\n\n![正常内存](../../../../img/leak&debugger/2.jpg)\n\n---\n分割线\n___\n\n``` js\n/* 代码二 */\nvar obj = null;\nvar replaceObj = () => {\n    var oldObj = obj;\n    obj = {\n        memory: new Array(1000000).join('*'),\n        closeFn () {\n            /* 将函数调用移至闭包内 */\n            if (oldObj) {\n                console.log('hi')\n            }\n            console.log(123);\n        }\n    };\n    oldObj && oldObj.closeFn();\n    console.log('---------------------');\n}\n\nsetInterval(replaceObj, 1000)\n```\n\n上述代码调用结果如下图\n\n![有闭包时控函数调用](../../../../img/leak&debugger/4.jpg)\n\n断点进函数查看，函数内部存在闭包引用，每次创建的新对象都会引用上一个对象，导致每次创建的对象都不被GC回收。因为闭包引用而导致对象没有被回收，熟练使用谷歌调试也可以查出来,重点看代码三。\n\n---\n分割线\n___\n\n``` js\n/* 代码三 */\nvar obj = null;\nvar replaceObj = () => {\n    var oldObj = obj;\n\n    var unused = () => {\n        if (oldObj) {\n            console.log('hi')\n        }\n    }\n\n    obj = {\n        memory: new Array(1000000).join('*'),\n        closeFn () {\n            console.log(123);\n        }\n    };\n}\n\nsetInterval(replaceObj, 1000)\n```\n\n上述代码因为不能在闭包里面打印，所有用谷歌调试工具抓内存查看\n\n文中代码在浏览器中运行时的内存情况\n\n![文中代码内存情况](../../../../img/leak&debugger/5.jpg)\n\n导致内存泄露的原因是在同一个父作用域下创建闭包时，这个作用域是共享的。代码中closeFn的闭包作用域和unused的闭包作用域是共享的。即便unused函数从未被使用且不可能被使用，它对oldObj的引用造成了oldObj的活跃（阻止它被回收）。代码三中closeFn拥有的闭包与代码二中closeFn拥有的闭包相同。\n\n---\n**2019-04-04 记录，v8引擎修复了没有调用的函数对闭包的引用，但是在 closeFn 里面加上 debugger，可以看到还是保存了对闭包的引用。**\n___\n\n# 三、devTools调试\n\n##  Profiles视图\n\n在老版本谷歌上显示为Profiles，新版本谷歌改名为Menory，文中使用谷歌版本69。该功能可以对js内存进行快照，也可以记录一段时间内的内存分配情况，如下图。\n\n![快照、录像](../../../../img/leak&debugger/6.jpg)\n\n以上文代码三内存泄露为例，\n\n1.  快照\n\n快照中summary视图提供了不同类型的分配对象以及他们的合计大小。shallow size表示一个特定类型所有对象总和，retained size表示此对象的shallow size和保留此对象的其他对象的shallow size总和，distance表示对象到GC根（最初引用的那块内存）的最短距离。\n\n![快照](../../../../img/leak&debugger/7.jpg)\n\n图中的字符串的shallow size等于retained size，大概因为字符串不是引用类型。\n字符串上面的closeFn函数的shallow size只有56，二retained size的大小是3000640，是因为这个对象被其他对象引用，其他对象的总大小加上closeFn函数的shallow size得到3000640。\n图中可以看出，window的distance是1，即最接近GC根，往下的Object直接定义在window上所有distance是2，后面一层一层引用，引用得越深，distance越大。\n\n2.  对比快照\n\n快照中comparison视图提供了这一次快照与上一次快照直接的对比\n\n![快照对比](../../../../img/leak&debugger/8.jpg)\n\n这个视图里能清晰看出这一次快照与上一次快照新增，删除了多少对象。\n\n3.  录像\n\ndevTools还提供了录像功能，点击Profiles，选择第二个切换到录像。\n\n![切换录像](../../../../img/leak&debugger/9.jpg)\n\n开始录像后能清晰看到网页根据时间轴所产生的内存，可以选择某一时间段去查看其中的内存分配\n\n![录像](../../../../img/leak&debugger/10.jpg)\n\n## 参考文献\njavaScript中4种常见的内存泄露陷阱(http://web.jobbole/com/88463)\n本文全是作者对这篇文献的理解，或与原文有所不同，若有错误欢迎指出。","tags":["devtools"]},{"title":"WebRTC p2p h5 api科普","url":"/blog/2018/07/12/h5_webrtc-h5api/","content":"# WebRTC实现网页端到网页端互看的流程及demo\n\n##  一、什么是WebRTC\n\nWebRTC是网页**实时通信**（Web Real-Time Communication）的缩写，可以让网页**无需安装插件**，进行**实时**语音对话或视频对话的技术，此例实现的是网页之间实时视频通信。\n\n## 二、准备所需材料\n\n2台有摄像头的电脑、高版本浏览器（这里用到是谷歌65）、信令服务器（可以用node实现，也可以用sip实现，作用是把页面的生成的数据发送给对端）、https服务器（webRTC访问本地设备需要https）\n\n## 三、WebRTC流程\n\n![WebRTC流程图](../../../../img/h5_webrtc-h5api/pc流程图.png)\n\n备注：图中Signal Server（黄色）为信令服务器，可以理解为传递数据用的后台，图中部分老规范方法已经弃用，需用新规范方法代替。\n\n1.  A端和B端与信令服务建立连接，作为之后将A，B端消息交互的通道。\n\n2.  A端调用创建WebRTC对象，传入一个参数，与打洞服务器有关。\n\n``` js\nlet pc = new RTCPeerConnection(null);\n```\n3.  A端调用 **navigator.getUserMedia** 方法获取本地流stream，给video标签设置srcObject属性即可看到本地画面，并调用 **addTrack（图中AddStreams）** 方法将流添加至通道中。\n\n``` js\n//获取本地流\n//第一个参数为分辨率限制，不需要则如下传值，第二个为成功回调，第三个为错误回调\n//由于 navigator.getUserMedia 是异步方法，可修改为同步函数\nlet getNavMedia = () => {\n  return new Promise((resolve, reject) => {\n    navigator.getUserMedia({\n      audio: true,\n      video: true\n    }, (stream) => {\n      resolve(stream);\n    }, (error) => {\n      console.log(`navigator.getUserMedia error: ${error}`);\n      resolve(error);\n    });\n  });\n};\n\nlet mediaStream = await getNavMedia();\n//设置video标签属性，显示视频\nif (mediaStream.id) {\n  myVideo.srcObject = mediaStream\n}\n\n// 在通道中添加流，图中add Streams过程\nmediaStream.getTracks().forEach(\n    function (track) {\n        pc.addTrack(\n            track,\n            mediaStream\n        );\n    };\n);\n```\n\n4.  A端调用 **createOffer** 生成offer（一个标准的sdp协议，大概包含音视频格式码流等信息），再调用 **setLocalDescription** 设置本地sdp（offer），并经过信令服务器发送至B端。\n\n``` js\n// createOffer返回一个promise，所以可以直接写成async\nlet offer = await pc.createOffer();\n\n// 或者用.then来调用，成功回调返回一个offer参数\npc.createOffer().then(successBack, errorBack);\n\n// setLocalDescription同createOffer，返回一个promise，只不过没有返回\npc.setLocalDescription(offer)\n```\n\n5.  B端接收到offer之后，调用 **setRemoteDescription** 设置远端sdp（offer），再调用 **createAnswer** 生产answer（与offer相对），调用 **setLocalDescription** 设置本地sdp（answer），并经过信令服务器发送至A端。\n\n``` js\n// setRemoteDescription, createAnswer皆返回promise\n// 这里设置远端sdp完成才能生成对应answer，\n// 否则会报错CreateAnswer can't be called before SetRemoteDescription.\nawait pc.setRemoteDescription(offer)\n\nlet answer = pc.createAnswer()\n\npc.setLocalDescription(answer)\n```\n\n6.  A端接收到answer后，调用 **setRemoteDescription** 设置远端sdp（answer）。\n``` js\npc.setRemoteDescription(answer)\n```\n\n#### 以下为RTCPeerConnection事件，应该在第二步创建之后绑上\n\n7.  第1-第6步过程中会生产icecandidate（浏览器打洞相关）数据，并且触发RTCPeerConnection对象的 **onicecandidate** 事件，这些icecandidate数据需要发送至对端，对端调用 **addIceCandidate** 添加。\n``` js\n// 产生icecandidate\npc.onicecandidate = (e) => {\n  if (e.candidate) {\n    console.log(e.candidate)\n    ...// 经过信令服务器发送至对端\n  }\n}\n\n// 接收icecandidate\npc.addIceCandidate(candidate)\n```\n\n8.  所有流程正常运行后，会触发pc的 **ontrack** 事件，并给出对端流，给video标签设置srcObject属性即可看到对端画面\n``` js\npc.ontrack = (e) => {\n  if (e.streams) {\n    //设置video标签属性，显示视频    \n    peerVideo.srcObject = e.streams[0]\n  }\n}\n```\n\n9.  **pc.onremovestream** 失去对端流事件\n\n## 四、项目地址\n[https://github.com/HowGraceU/WebRTC_p2p](https://github.com/HowGraceU/WebRTC_p2p) \n\n## 五、参考文献\nWebRTC权威指南.pdf（已上传至项目中）","tags":["WebRTC"]}]