[{"title":"php面向对象","url":"/yideng/2019/03/10/php-oop/","content":"\n**OOP目标：重用性、灵活性、扩展性。特点：封装、继承、多态**\n**对象特征：行为、状态、标识。**\n\n## 类的声明\n\n### 成员属性\n\n**格式 修饰符 $变量名 [=默认值]**\n\n``` php\npublic $var = 100; // 普通数值（整数、浮点数、布尔、字符串）\npublic $var = myConst; // 常量\npublic $var = self::classConstant; // 静态属性\npublic $var = array(1, 2); // 数组\n```\n\n### 成员方法\n\n**格式 修饰符 function 方法名() {}**\n\n### 实例化对象\n\n**$对象名称 = new 类名([arg])**\n\n### 属性访问\n\n``` php\n$对象名称->成员属性  // 获取\n$对象名称->成员属性 = 赋值 // 赋值\n$对象名称->成员方法()  // 调用\n```\n\n### $this\n\n**php 中的 this 指向实例。**\n``` php\nclass Car{\n    public $name;\n    public function logName() {\n        echo \"this name is {$this -> name}\";\n        return 'ok';\n    }\n}\n\n$BMW = new Car();\n$BMW -> name = 'BMW';\n$ret = $BMW -> logName();\necho('<br/>');\necho($ret);\n```\n\n### 构造方法\n\n**new 对象的时候调用**\n\n**[修饰符] function__constructor() {}**\n\n### 析构方法\n\n**对象被销毁或没有代码再执行的时候调用**\n\n**[修饰符] function__constructor() {}**\n\n``` php\nclass Car{\n    public function __construct($name) {\n        $this -> name = $name;\n    }\n\n    public function logName() {\n        echo \"this name is {$this -> name}\";\n        return 'ok';\n    }\n\n    public function __destruct() {\n        echo 'delete';\n    }\n}\n\n$BMW = new Car('BMW');\n$ret = $BMW -> logName();\necho('<br/>');\necho($ret);\necho('<br/>');\n\n// 打印 \n// this name is BMW\n// ok\n// delete\n```\n## 封装\n\n### 修饰符\n\n**public 公有。private 私有，只能在class里访问。protected 受保护，只能在class里访问，继承时候有行为。**\n\n### 魔术方法\n\n**public 公有。private 私有，只能在class里访问。protected 受保护，只能在class里访问，继承时候子类可以访问。**\n\n**__set，设置private或者protected属性时触发。**\n\n**__get，获取private或者protected属性时触发。**\n\n**__isset，判断private或者protected属性存在时出发。**\n\n**__unset，删除private或者protected属性时触发。**\n\n``` php\nclass Car{\n    public function __construct($pb, $pv, $pt) {\n        $this -> pb = $pb;\n        $this -> pv = $pv;\n        $this -> pt = $pt;\n    }\n\n    public $pb;\n    private $pv;\n    protected $pt;\n\n    public function __set($key, $val) {\n        echo \"{$key} {$val}\";\n    }\n\n    public function __get($key) {\n        echo \"{$key}\";\n        return $this -> $key;\n    }\n    \n    public function __isset($key) {\n        echo \"{$key}\";\n        return false;\n    }\n\n    public function __unset($key) {\n        echo \"{$key}\";\n        return false;\n    }\n}\n\n$BMW = new Car('1', '2', '3');\n$BMW -> pb = '4';\n// 不打印\necho '<br/>';\n$BMW -> pv = '5';\n// 打印 pv 5\necho '<br/>';\n$BMW -> pt = '6';\n// 打印 pt 6\necho '<br/>';\n\necho '<br/>';\necho $BMW -> pb;\n// 打印 4\necho '<br/>';\necho $BMW -> pv;\n// 打印 pv2\necho '<br/>';\necho $BMW -> pt;\n// 打印 pt3\necho '<br/>';\n\necho '<br/>';\nvar_dump(isset($BMW -> pb));\n// 打印 bool(true) \necho '<br/>';\nvar_dump(isset($BMW -> pv));\n// 打印 pvbool(false) \necho '<br/>';\nvar_dump(isset($BMW -> pt));\n// 打印 ptbool(false) \necho '<br/>';\n\necho '<br/>';\nunset($BMW -> pb);\n// 打印 pb  unset的时候会触发公共属性的get？\necho $BMW -> pb;\n// 报错\necho '<br/>';\nunset($BMW -> pv);\necho $BMW -> pv;\n// pvpv2\necho '<br/>';\nunset($BMW -> pt);\necho $BMW -> pt;\n// ptpt3\necho '<br/>';\n```\n\n## 继承\n\n### 重写和重载\n\n**public 公有。private 私有，只能在class里访问。protected 受保护，只能在class里访问，继承时候子类可以访问。**\n\n**父类的非私有的方法和属性可以重载或者重写，重载时需要调用一次父级的方法。**\n\n``` php\nclass Car{\n    public $pb;\n    private $pv;\n    protected $pt;\n\n    public function __construct($pb, $pv, $pt) {\n        $this -> pb = $pb;\n        $this -> pv = $pv;\n        $this -> pt = $pt;\n    }\n\n    public function log() {\n        echo $this -> pb;\n        echo '<br/>';\n        echo $this -> pv;\n        echo '<br/>';\n        echo $this -> pt;\n    }\n}\n\nclass BMW extends Car{\n    public function __construct($pb, $pv, $pt) {\n        parent::__construct($pb, $pv, $pt);\n    }\n\n    public function log($val) {\n        echo \"reload {$val}\";\n        echo '<br/>';\n        parent::log();\n    }\n\n    public function logPv() {\n        echo $this -> pt;\n    }\n}\n\n$bmw = new BMW(1, 2, 3);\n$bmw -> logPv();\n// 打印3\n$bmw -> log(666);\n// 打印 eload 666\n// 1\n// 2\n// 3\n```","tags":["OOP"]},{"title":"php笔记","url":"/yideng/2019/03/10/php/","content":"\n## 块级作用域\n``` php\nif (true) {\n    $a = 1;\n    echo $a;\n}\necho $a;\n// 打印 1\n\nif (false) {\n    $a = 1;\n}\necho $a;\n// 报错\n```\n\n## 检查是否声明\n``` php\nif (isset($a)) {\n    echo 'set a;';\n}\n\nif (!isset($b)) {\n    echo 'unset b;';\n}\n// 打印 set a;unset b;\n```\n\n## 全局变量\n``` php\n$a = 'out';\nfunction t() {\n    echo $a;\n}\nt();\n// 报错\n\n$a = 'out';\nfunction t() {\n    global $a;\n    echo $a;\n}\nt();\n// 打印 out\n```\n\n## 数组\n``` php\n$cars = array(\"Volvo\", \"BMW\");\necho json_encode($cars);\n// 打印 [\"Volvo\",\"BMW\"]\n$name = array(\"name\" => \"jqx\");\necho json_encode($name);\n// 打印 {\"name\":\"jqx\"}\n$cars_name = array(\"Volvo\", \"BMW\", \"name\" => \"jqx\");\necho json_encode($cars_name);\n// 打印 {\"0\":\"Volvo\",\"1\":\"BMW\",\"name\":\"jqx\"}\n```\n\n## session\n\n**php的session和js不同，php以浏览器为单位，js以当前页面为单位**\n\n``` php\nsession_start();\n// 存储 session 数据\nif(isset($_SESSION['views']))\n{\n    $_SESSION['views']=$_SESSION['views']+1;\n}\nelse\n{\n    $_SESSION['views']=1;\n}\n\n\n// 检索 session 数据\necho \"浏览量：\". $_SESSION['views'];\n```\n\n## 表单请求\n**$_GET, $_POST, $_REQUEST**\n\n**获取 application/json; 消息得使用 file_get_contents('php://input');**\n\n``` js\n// 前端测试代码\n(async() => {\nlet body = await fetch('/jqx/request.php', {\n    body: JSON.stringify({\n\t\t\tadmin: 'jqx',\n\t\t\tpsword: '123456'\n\t\t}), // must match 'Content-Type' header\n    headers: {\n      'content-type': 'application/json'\n    },\n    method: 'POST', // *GET, POST, PUT, DELETE, etc.\n  })\n\nlet json = await body.json();\nconsole.log(json);\n})()\n```\n\n## php链接数据库\n``` php\n$servername = \"localhost\";\n$username = \"username\";\n$password = \"password\";\n$dbname = \"test\";\n\n$conn = new mysqli($servername, $username, $password, $dbname);\n\nif ($conn->connect_error) {\n    die(\"连接失败: \" . $conn->connect_error);\n} \necho \"连接成功\";\n```\n\n## php操作数据库\n```php\n$sql = \"INSERT INTO user (username, email)\nVALUES ('jqx', '272670445@qq.com')\";\n \nif ($conn -> query($sql) === TRUE) {\n    echo \"新记录插入成功\";\n} else {\n    echo \"Error: \" . $sql . \"<br>\" . $conn->error;\n}\n \n$conn -> close();\n```\n\n## php PDO\n``` php\n$dbms='mysql';     //数据库类型\n$host='localhost'; //数据库主机名\n$dbName='test';    //使用的数据库\n$user='root';      //数据库连接用户名\n$pass='';          //对应的密码\n$dsn=\"$dbms:host=$host;dbname=$dbName\";\n\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象\n    echo \"连接成功<br/>\";\n\n    $dbh = null;\n} catch (PDOException $e) {\n    die (\"Error!: \" . $e->getMessage() . \"<br/>\");\n}\n//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT => true) 变成这样：\n$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n```\n\n## PDO 数据库操作\n``` php\n// 查询\nforeach ($dbh->query('SELECT * from user') as $row) {\n    $ret = json_encode($row);\n    echo(\"$ret</br>\"); //你可以用 echo($GLOBAL); 来看到这些值\n}\n\n// 执行语句\n$count = $dbh->exec(\"UPDATE user SET email = '272670445@163.com' WHERE username = 'jqx'\");\necho \"受影响行数{$count}\"\n```","tags":["php"]},{"title":"js和后台语言的差异","url":"/yideng/2019/03/08/js-OOP/","content":"\n## 强类型\n\n**强类型优势：**\n**1.  数据类型固定不变，减少了程序由于数据类型问题报错的概率，保证程序健壮性。**\n**2.  所有变量类型确定，增加了一定可读性。**\n\n## 变量\n\n### var 声明变量\n\n**使用 var 关键字声明变量，会导致变量的提升。在 let 出现之后，这个问题很好的解决了。**\n\n``` js\nconsole.log(a);\nvar a = 1;\n// 打印 undefined\n\nconsole.log(a);\nlet a = 1;\n// 报错 b is not defined\n```\n\n### function 声明\n\n**使用 function 关键字声明函数时，会导致函数提升，提升的方式与浏览器的版本密切相关。**\n\n``` js\nfunction test() {\n    console.log('out');\n}\n\n(function () {\n    if (false) {\n        function test() {\n            console.log('in');\n        }\n    }\n\n    test()\n})()\n\n// 老版本浏览器 打印 in\n// 新版本浏览器 报错 test is not a function\n```\n\n**在ES6的浏览器中，它们的行为实际上是这样的：**\n\n**1.   允许块级作用域中定义函数。**\n\n**2.   函数声明实际上将会类似于使用 var 声明的函数表达式，函数名将会提升至当前函数作用域顶。**\n\n**3.   同时函数声明也会保持在块级作用域中的提升行为。**\n\n**上述代码在现代浏览器中类似：**\n\n``` js\nvar test;\ntest = function () {\n    console.log('out');\n}\n\n(function () {\n    var test;\n    if (false) {\n        test = function () {\n            console.log('in');\n        }\n    }\n\n    test();\n})()\n```\n\n## this\n\n**一般后台语言中的 this 就指向当前class类，但js 中 this 是多变的，这已经是老生常谈了。js 中的 this 分了三种情况。**\n\n**1.   普通函数调用，this 指向window。**\n\n**2.   对象调用，this 指向调用方法的对象。**\n\n**3.   构造函数，this 指向返回的实例。**\n\n## 函数参数\n\n**js 中的函数在运行时，传入的参数与定义时的参数数量可以不同，在函数内可以通过 arguments 对象取得未定义的参数，这使 js 有时候变得方便，但是缺失了函数的重载（可以通过一些[技巧](../../06/js-skill/)实现函数重载）**\n\n## 数组\n\n**js 中的数组不是真的数组，他属于对象。当数组下标都是连续时，数组为快数组，而下标不连续时，数组就变成了 map。当操作只有出栈入栈时，js 数组的性能会不如 List。**\n\n**[从Chrome源码看JS Array的实现](https://zhuanlan.zhihu.com/p/26388217)**\n\n## 面向对象\n\n**在 es6 到来之前，网上流传了多个版本的使用 es3 实现类和继承，其中最为出名的就是基于原型的继承方式。**\n\n**在 es6 中引入 Class 关键字，这简直太棒了，避免了各个公司或插件实现的继承不同而造成阅读代码困难的问题，并且 Class 使用起来相对方便。**\n\n**但是 Class 暂时还没有私有变量的概念，不想其他的后端语言。**","tags":["js"]},{"title":"jquery 技术内幕","url":"/yideng/2019/03/04/jquery-technology-insider/","content":"\n<script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"></script>\n\n**记录前端鼻祖 ———— jquery 的 js 技巧**\n\n### jquery 对象\n\n**在没有 es6 的 Class 之前，js 中都使用 function 以及他的 propotype 来实现面向对象。但是尽管如此，总有人在初始化实例时，忘记加上 new 关键字，这就会造成意外的全局污染。**\n\n``` js\nfunction Person(name) {\n    this.name = name;\n}\n\n// 正常使用\nvar man = new Person('老王');\nconsole.log(man.name); // 打印 老王\n\n// 忘记带 new\nvar man = Person('老王');\nconsole.log(window.name); // window 添加了一个变量 name\n```\n\n**这就会在你不知情的情况下，定义了一个全局变量。而 jquery 在生成新对象的时候，从来都没有带上 new 关键字，jquery 在创建对象时使用了一个技巧。**\n\n``` js\nfunction Person(name) {\n    this.name = name;\n}\n\nfunction createPerson(name) {\n    return new Person(name);\n}\n\nvar man = new createPerson('老王');\nvar woman = createPerson('小丽');\n\nconsole.log(man.name); // 打印 老王\nconsole.log(woman.name); // 打印 小丽\nconsole.log(man.prototype === woman.prototype); // 打印 true\n```\n\n**使用 new 关键字后，如果函数 return 了一个对象，返回对象，若返回的不是对象则创建一个新对象返回。**\n\n**在 createPerson 函数返回了一个 new Preson，使得即使不使用 new 关键字也可以创建对象实例，既保证创建对象时的安全，也方便调用。**\n\n**源码中的代码：**\n\n![jquery_init](../../../../img/jquery_technology_insider/jquery_init.png)\n\n### jquery 原型\n\n**在使用 jquery 的插件时，在 $.fn 上扩展方法，对象 $() 上就能访问刚刚挂载的方法。**\n\n``` js\n$.fn.log123 = function () {\n    console.log(123)\n}\n\n$().log123() // 打印 123\n```\n\n**再结合上面返回的 $.fn.init 实例，可见 $.fn 就是 $.fn.init.prototype。的确在源码中也做了这样的定义，使得返回的对象可以拿到原型上的方法。**\n\n![jquery_init_propotype](../../../../img/jquery_technology_insider/jquery_init_propotype.png)\n\n**再附上一张 jquery 非常绕的原型图：**\n\n![jquery_propotype](../../../../img/jquery_technology_insider/jquery_propotype.png)\n\n### 类型判断\n\n**在判断一个对象是 json 还是 array 的时候，公认的有效的方法是使用 Object.prototype.toString.call( Obj )。对于得到的字符串还要进行 slice 才能拿到对象真正的类型。**\n\n**在 jquery 中，建立了一个 map 来获取对象的类型。**\n\n``` js\nconst class2type = {};\n\n\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ).forEach(name => {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n})\n\n/*\n* 得到\n* {\n*   \"[object Boolean]\": \"boolean\",\n*   \"[object Number]\": \"number\",\n*   \"[object String]\": \"string\",\n*   \"[object Function]\": \"function\",\n*   \"[object Array]\": \"array\",\n*   \"[object Date]\": \"date\",\n*   \"[object RegExp]\": \"regexp\",\n*   \"[object Object]\": \"object\",\n*   \"[object Error]\": \"error\",\n*   \"[object Symbol]\": \"symbol\"\n* }\n*/  \n\nconst toString = class2type.toString;\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n```","tags":["jquery"]},{"title":"css 矩阵和 tramsform 之间换算","url":"/yideng/2019/03/03/css-matrix/","content":"\n**在学数学时，同学们总在一起打趣：学这么多的函数运算有什么用，以后买菜总不能先列一个函数，算出该付多少钱吧。可谁知，在科技高速发展的时代，打趣的话也快要“实现”了。**\n**在 css3 中，退出了新属性——— matrix(矩阵)，这不正是大一时候学的线性代数吗（好在大一的时候还不是很皮，都认真听讲了）**\n\n### 矩阵计算\n\n**css3 中的 matrix 用来代替多个 transfrom 属性或者一些 transfrom 无法实现的效果，就来看一看 matrix 是怎么实现变换的吧。**\n\n**首先来看一下矩阵的参数：**\n``` js\ntransform: matrix(a,b,c,d,e,f);\n```\n\n**这6个参数提供了一个 3 * 3 的矩阵，而经过这个矩阵能够计算出变换前的 x，y 值与变换后的 x，y 值的关系。反应式如下：**\n\n![matrix](../../../../img/css-matrix/matrix.gif)\n\n**其中 x，y 为变化前的坐标，ax+cy+e 为变换后的 x'，bx+dy+f 表示变换后的 y'。**\n**举个例子，如果我们有一个矩形有 A(0, 0) B(200, 0) C(0, 100) D(200, 100) 四个点组成，经过矩阵转换后，我们希望得到如下变换：**\n\n![transfrom](../../../../img/css-matrix/transfrom.png)\n\n**在 css 中，坐标轴的零点都是左上角，x 轴和 y 轴的方向也与数学中的坐标轴有所不同。也就是我们需要得到的矩阵坐标为 A'(300, 100) B'(300, 300) C'(400, 100) D'(400, 300)，那么就可以根据公式 ax+cy+e=x'，bx+dy+f=y' 算出 a,b,c,d,e,f 各为多少。**\n\n``` js\n// 将 A(0, 0) 和 A'(300, 100) 两点带入 ax+cy+e=x' bx+dy+f=y'\na * 0 + c * 0 + e = 300;\nb * 0 + d * 0 + f = 100;\n\ne = 300;\nf = 100;\n\n// 以此类推，将四个点全部带入计算得出 a,b,c,d,e,f 四个值\n// 此例中为 \ntransform: matrix(0, 1, 1, 0, 300, 100);\n```\n\n**最终矩阵变换的效果图如下**\n\n<iframe src=\"https://howgraceu.github.io/demo/matrix/\" style=\"margin-left: -2em; width: 100%; height: 225px;\"><iframe>\n\n### matrix 与 transfrom 各个属性的转换。\n\n**transfrom 的各个属性能够与 matrix 相互转换。**\n\n``` css\n/* matrix 默认值 */\ntransform: matrix(1, 0, 0, 1, 0, 0);\n\n/* translate */\ntransform: translate(x, y);\ntransform: matrix(0, 0, 0, 0, x, y);\n\n/* scale */\ntransform: scale(x, y);\ntransform: matrix(x, 0 * x, 0 * y, y, 0, 0);\n\n/* rotate */\nrotate: rotate(θ);\ntransform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0);\n```\n\n**张鑫旭大神的博客[理解CSS3 transform中的Matrix](https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/) 一文对此有详细的解释。**\n\n**但是需要注意的是，当 scale 和 rotate 一起使用的时候，两者的值需要相乘。**\n\n``` css\n/* scale 2 */\ntransform: scale(x, y);\nrotate: rotate(θ);\n\ntransform: matrix(cosθ * x, sinθ * x, -sinθ * y, cosθ * y, 0, 0);\n```\n\n### matrix 与 transfrom 转换函数。\n\n**根据 matrix 与 transfrom 之间的关系，可以提出一个函数来进行两者之间的转换（转换顺序为先 transfrom 再 rotate）。**\n\n``` js\nconst PI = Math.PI;\n\nfunction encodeMatrix({translateX = 0, translateY = 0, rotate=0, scaleX=1, scaleY=1} = {}) {\n    let rad = rotate * PI / 180;\n    let a = scaleX * Math.cos(rad);\n    let b = scaleX * Math.sin(rad);\n    let c = scaleY * -Math.sin(rad);\n    let d = scaleY * Math.cos(rad);\n    let e = translateX;\n    let f = translateY;\n\n    return [a,b,c,d,e,f]\n}\n\nfunction decodeMatrix([a = 1, b = 0, c = 0, d = 1, e = 0, f = 0] = []) {\n    let translateX = e;\n    let translateY = f;\n    let scaleX = Math.round(Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)));\n    let scaleY = Math.round(Math.sqrt(Math.pow(c, 2) + Math.pow(d, 2)));\n    let radC = Math.acos(a / scaleX);\n    let radS = Math.asin(b / scaleX);\n\n    let rad\n    if (b >= 0) {\n        rad = radC;\n    } else if (b < 0) {\n        rad = 2 * PI - radC;\n    }\n\n    let rotate = Math.round(rad * 180 / Math.PI);\n\n    return {translateX, translateY, rotate, scaleX, scaleY}\n}\n\nlet matrix = encodeMatrix({translateX: 30, translateY: 40, rotate: 45, scaleX: 2, scaleY: 3});\n//  [1.4142135623730951, 1.414213562373095, -2.1213203435596424, 2.121320343559643, 30, 40]\n\nlet transfrom = decodeMatrix([1.4142135623730951, 1.414213562373095, -2.1213203435596424, 2.121320343559643, 30, 40]);\n// {translateX: 30, translateY: 40, rotate: 45, scaleX: 2, scaleY: 3}\n```\n\n**上述函数在自己写的一个 [svg-editor](https://howgraceu.github.io/demo/svg/) 的例子中使用，但是在使用过程中发现如果缩放倍数不为整数时，可能会得到不精确的结果，导致最后结果偏差较大。**\n\n**最后附上一个用于转化 transfrom 和 matrix 的网页，[meyerweb-matrix](https://meyerweb.com/eric/tools/matrix/)**","tags":["matrix"]},{"title":"一灯笔记测试","url":"/yideng/2019/02/28/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["blogTest"]}]