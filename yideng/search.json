[{"title":"函数式编程 - 函子","url":"/yideng/2019/03/19/Lambda/","content":"\n**函数式编程通过管道把数据在一系列纯函数间传递。但是，控制流（control flow）、异常处理（error handling）、异步操作（asynchronous actions）和状态（state）呢？还有更棘手的作用（effects）呢？我们都将借助函子帮我们完成。**\n\n**函子是函数式编程中最重要的数据类型，也是基本的运算单位和功能单位。**\n\n## 容器\n\n**我们创建一个容器，这个容器就职于装载值，并且不会向容器添加新属性或者方法。**\n\n``` js\nclass Container {\n    constructor (value) {\n        this.__value = value;\n    }\n\n    static of(value) {\n        return new this(value);\n    }\n\n    map(f) {\n        return Container.of(f(this.__value));\n    }\n}\n\nlet concat = x => y => y.concat(x);\nlet prop = x => y => y[x];\n\nContainer.of(\"bombs\") // Container('bombs')\n    .map(concat(' away')) // Container('bombs away')\n    .map(prop('length')) // Container(10)\n```\n\n**这样我们就能够在不离开 Container 的情况下操作容器里面的值，并且这很函数式。**\n\n## Maybe\n\n**错误处理时，可以使用 Maybe 函子**\n\n``` js\nclass Maybe extends Container {\n    constructor (value) {\n        super(value);\n    }\n\n    isNothing() {\n        return (this.__value === null || this.__value === undefined);\n    }\n\n    map(f) {\n        return this.isNothing() ? Maybe.of(null) : Maybe.of(f);\n    }\n}\n\nlet retNull = () => null;\n\nMaybe.of(\"bombs\") // Maybe('bombs')\n    .map(concat(' away')) // Maybe('bombs away')\n    .map(retNull) // Maybe(null)\n    .map(prop('length')) // 当检测到 value 为null，不运行 prop 函数，避免函数运行时报错，返回 Maybe(null)\n```\n\n## Either\n\n**数学中没有 if...else，我们可以用 either 纯函数来处理 if...else**\n\n``` js\nclass Either extends Container {\n    constructor(left, right) {\n        super();\n        this.left = left;\n        this.right = right;\n    }\n\n    static of(left, right) {\n        return  new this(left, right);\n    }\n\n    map(f) {\n        return this.right ? \n            Either.of(this.left, f(this.right)) :\n            Either.of(f(this.left), this.right);\n    }\n}\n\nlet lenLtNum = num => str => str.length < num;\nlet lenLt4 = lenLtNum(4);\n\nEither.of(\"jqx\", \"bombs\") // Either(\"jqx\", \"bombs\")\n    .map(lenLt4) // Either(\"jqx\", false)\n    .map(concat(' away')) // Either(\"jqx away\", false)\n    .map(prop('length')) // Either(8, false)\n```\n\n## IO\n\n**我们有很多的不纯的操作，如取 storage 缓存，向后台请求接口，我们把这些函数包装在IO函子中，让调用者替我们承当不纯的部分。**\n\n``` js\nclass IO extends Container {\n    constructor(f) {\n        super(f);\n    }\n\n    map(f) {\n        return new IO(_.compose(f, this.__value));\n    }\n}\n\nlet retWin = () => window;\nlet getInnerWidth = win => win.innerWidth;\nlet unsafeWidth = IO.of(retWin).map(getInnerWidth);\n\nunsafeWidth.__value(); // 调用不纯函数得到窗口宽度\n```\n\n## Monad\n\n**下面有两个不纯的函数，但是把他们包装一下，每次都返回 IO 函子，包装他们的函数是一个纯函数。**\n\n``` js\nconst fs = require('fs');\n\nlet readFile = function(filename) {\n    return new IO(function() {\n        return fs.readFileSync(filename, 'utf-8');\n    });\n};\n\nlet print = function(x) {\n    return new IO(function() {\n        console.log(x);\n        return x;\n    });\n}\n\nlet getUser = readFile('./user.txt') // IO{ val: f => user }\n                .map(print) // IO{ val: f => IO { f => user }}\n\ngetUser.__value().__value(); // 拿到 user\n```\n\n**若 IO 函子 map 了一个不纯的函数，则会得到一个 IO 里面包装 IO 的函子，提供一个 Monad 函数处理这种情况。**\n\n``` js\nclass Monad extends Container {\n    join() {\n        return this.__value;\n    }\n\n    flatMap(f) {\n        return this.map(f).join();\n    }\n}\n\nclass IO extends Container {\n    map(f) {\n        return new IO(_.compose(f, this.__value));\n    }\n\n    flatMap(f) {\n        // 这里要扩展父的 flatMap 是因为 IO 函子里面放的是函数，\n        // 得将之运行一下，返回输出的 IO 扁平化，若函子里面放的是纯数据则不需要扩展\n        return super.flatMap(f)();\n    }\n}\n\nlet getUser = readFile('./user.txt') // IO{ val: f => user }\n                .flatMap(print) // IO{ val: f => IO { f => user }}\n\ngetUser.__value(); // 拿到 user\n\nlet getName = prop('name');\n\nlet getUserName = readFile('./user.txt') // IO{ val: f => user }\n                .flatMap(print) // IO{ val: f => IO { f => user }}\n                .map(getName)\n\ngetUserName.__value(); // 拿到 userName\n```\n","tags":["lambda"]},{"title":"函数式编程","url":"/yideng/2019/03/19/functional/","content":"\n<script src=\"https://cdn.bootcss.com/lodash.js/4.17.12-pre/lodash.js\"></script>\n\n**js中函数是一等公民，这句话意味着函数和其他数据类型一样，可以赋值给其他变量，也可以作为参数传入另一个函数，或者作为别的函数的返回值。**\n\n# 纯函数\n\n**对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的函数称之为纯函数**\n\n``` js\nlet xs = [1, 2, 3, 4, 5];\n\n// slice 是纯函数，固定输入得到固定输出，没有副作用\nxs.slice(0, 3) // [1, 2, 3] xs不变\nxs.slice(0, 3) // [1, 2, 3] xs不变\nxs.splice(0, 3) === xs.splice(0, 3) // [1, 2, 3] xs变成[4, 5]\nxs.splice(0, 3) === xs.splice(0, 3) // [4, 5] xs变成[]\n```\n\n## 纯函数的优点\n\n### 可缓存性\n**由于固定输入得到固定输出，所以可以将函数结果缓存起来。**\n\n``` js\nimport _ from 'loadsh';\nconst sin = _.memorize(x => Math.sin(x));\n\nsin(1);\n\n// 第二次计算有了换成。速度会变快\nsin(2);\n```\n\n### 可移植性\n\n**命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它。**\n\n``` js\n// 不纯的\nvar signUp = function(attrs) {\n  var user = saveUser(attrs);\n  welcomeUser(user);\n};\n\nvar saveUser = function(attrs) {\n    var user = Db.save(attrs);\n    ...\n};\n\nvar welcomeUser = function(user) {\n    Email(user, ...);\n    ...\n};\n\n// 纯的\nvar signUp = function(Db, Email, attrs) {\n  return function() {\n    var user = saveUser(Db, attrs);\n    welcomeUser(Email, user);\n  };\n};\n\nvar saveUser = function(Db, attrs) {\n    ...\n};\n\nvar welcomeUser = function(Email, user) {\n    ...\n};\n```\n\n### 可测试性\n\n**纯函数让测试更加容易。只需简单地给函数一个输入，然后断言输出就好了。**\n\n# 函数柯里化\n\n**传给函数部分参数，返回一个函数处理剩下的参数。**\n\n``` js\nlet comparedAge = (min, age) => min < age;\n\nlet initMinAge = (min) => {\n    return (age) => comparedAge(min, age)\n}\n\nlet checkAge19 = initMinAge(19);\n\ncheckAge19(15); // false\ncheckAge19(23); // true\n```\n\n**以下为个人查阅 lodash 源码，制作的简化版的 curry**\n\n``` js\nconst curry = (func, partials, arity=func.length)=>{\n    const wrapper = function() {\n        let length = arguments.length;\n        let args = Array(length);\n        let index = length;\n\n        while (index--) {\n            args[index] = arguments[index];\n        }\n\n        if (partials) {\n            args = args.concat(partials);\n        }\n\n        if (length < arity) {\n            return curry(func, args, arity - length);\n        }\n\n        return func.apply(window, args.reverse());\n    }\n    return wrapper;\n}\n\nlet abc = function(a, b, c) {\n    return [a, b, c];\n};\n\nlet a = curry(abc);\n\nconsole.log(a(1)(2)(3)); // [1, 2, 3]\n\nlet b = a(4);\nconsole.log(b(5)(6)); // [4, 5, 6]\n\nlet c = a(7)(8);\nconsole.log(c(9)); // [7, 8, 9]\n```\n\n# 代码组合\n\n**f 和 g 都是函数，x 是在它们之间通过“管道”传输的值。特性有结合律，符合结合律意味着不管你是把 g 和 h 分到一组，还是把 f 和 g 分到一组都不重要。**\n\n``` js\nvar compose = function(f,g) {\n    return function(x) {\n        return f(g(x));\n    };\n};\n\n// 结合律（associativity）\nvar associative = compose(f, compose(g, h)) == compose(compose(f, g), h);\n// true\n```\n\n## pointfree\n\n**函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。**\n\n``` js\n// 非 pointfree，因为提到了数据：word\nvar snakeCase = function (word) {\n    return word.toLowerCase().replace(/\\s+/ig, '_');\n};\n\n// pointfree\nvar replace = function (reg, replaceStr) {\n    return function (str) {\n\t\treturn str.replace(reg, replaceStr);\n\t}\n}\n\nvar toLowerCase = function (str) {\n\treturn str.toLowerCase();\n}\n\nvar snakeCase = compose(replace(/\\s+/ig, '_'), toLowerCase);\n\nsnakeCase('A B'); // a_b\n```\n\n## debug\n\n**如果在 debug 组合的时候遇到了困难，那么可以使用下面这个实用的，但是不纯的 trace 函数来追踪代码的执行情况。**\n\n``` js\nvar trace = curry(function(tag, x){\n  \tconsole.log(tag, x);\n  \treturn x;\n});\n\nvar snakeCase = compose(replace(/\\s+/ig, '_'), compose(trace('[snakeCase]'), toLowerCase));\n\nsnakeCase('A B');\n// log  [snakeCase] a b\n// 返回 a_b\n```\n\n# 尾递归\n\n**尾递归的判断标准是函数的最后一步是否调用自身。尾递归调用栈永远都是更新当前的栈帧，这样就避免了爆栈的危险，而浏览器并未支持，原因有 1.在引擎曾消除递归是隐式行为，程序员意识不到。2. 堆栈信息丢失导致开发者难以调试。我们可以将递归写成while。**\n\n``` js\n// 传统递归\nfunction sum(n) {\n    if (n === 1) return 1;\n    return n + sum(n - 1);\n}\n\nsum(5);\n// 调用栈\nsum(5)\n(5 + sum(4))\n(5 + (4 + sum(3)))\n(5 + (4 + (3 + sum(2))))\n(5 + (4 + (3 + (2 + sum(1)))))\n(5 + (4 + (3 + (2 + 1))))\n(5 + (4 + (3 + 3)))\n(5 + (4 + 6))\n(5 + 10)\n15\n\n// 尾递归调用\nfunction sum(n, total = 0) {\n    if (n === 1) return n + total;\n    return sum(n - 1, n + total);\n}\n\nsum(5);\n// 调用栈，每次调用栈都指向新返回的函数\nsum(5)\nsum(4, 5)\nsum(3, 9)\nsum(2, 12)\nsum(1, 14)\n15\n```","tags":["functional"]},{"title":"js 小细节","url":"/yideng/2019/03/12/js_details/","content":"\n**此贴用来记录一些 js 的小细节（常见坑）**\n\n### js 不能没有分号！！\n\n**先标题档一下，js 可以没有分号，但是某些时候又不得不加分号。在使用立即执行函数，容易在开头漏掉分号，以至于 js 把上一行的返回当成了一个函数来运行。**\n\n``` js\n(() => {alert(1)})() // alert 1\n(() => {alert(2)})() // 报错\n```\n\n### 同时声明同名函数与定义变量\n\n**在同时声明函数和定义变量时，如果没有给变量赋值，则函数生效。**\n\n``` js\nfunction foo() {}; // 定义函数在先\nvar foo;\n\nconsole.log(foo);\n// 打印 函数foo\n\nvar foo; // 定义变量在先\nfunction foo() {};\n\nconsole.log(foo);\n// 打印 函数foo\n```\n\n### 给变量赋值函数，且给函数名字。\n\n**给变量赋值函数，且给函数一个名字，在函数内部打印这个名字即指向该函数。函数内部无法给这个变量赋值，且外部无法获取这个变量。**\n\n``` js\nlet a = function foo() {\n    console.log(foo); // 打印 foo 函数\n    foo = 1;\n    console.log(foo); // 打印 foo 函数\n\n    // 若重新定义了 foo 变量，贼内部的 foo 不再指向函数。\n    // var foo = 1;\n    // console.log(foo); // 打印1\n}\n\nconsole.log(foo); // 报错 foo is not defined\n```\n\n### 不能 new es6 的函数\n\n**所谓 es6 的函数是指对象的简写函数和箭头函数。两者在 new 的时候都会报错，**\n\n``` js\nlet a = {\n    foo() {}\n}\n\nnew a.foo(); // a.foo is not a constructor\n\nlet foo = () => {};\n\nnew foo(); // foo is not a constructor\n```\n\n### new 的时候，函数内的 this 指向创建的实例\n\n**在调用 new 的时候，函数内的 this 指向创建的实例，且不能通过 bind 来改变。**\n\n``` js\nvar obj = {\n    a: 10,\n    foo: function () {\n        console.log(this.a);\n    }\n}\n\nvar obj2 = {\n    a: 20\n}\n\nobj.foo() // 打印 10\nvar myFoo = obj.foo.bind(obj2);\nmyFoo(); // 打印 20\nnew myFoo(); // 打印 undefined\n```\n\n### 原型链属性失效\n\n**当实例中定义过属性，即使是 undefined，也不会取原型链上的属性。**\n\n``` js\nfunction foo(a) {\n    this.a = a;\n}\nfoo.prototype.a = 10;\n\nconsole.log((new foo()).a); // 打印 undefined\n```\n\n### function 的变量提升\n\n**在老版本的浏览器中，声明函数会提升到当前函数作用域的顶端，在最后声明的函数在作用域内都可以使用。**\n\n``` js\nfoo(); // 打印 1\n\nif (false) {\n    function foo() {\n        console.log(1);\n    }\n}\n```\n\n**在支持 es5 的现代浏览器中，却是不同的结果。声明函数时，会先将定义变量（var foo）提升到<span style='color:Crimson;'>函数作用域</span>的顶端，然后在<span style='color:Crimson;'>块级作用域</span>顶端对函数赋值。**\n\n``` js\nconsole.log(foo); // foo 已经定义，打印 undefined\n{\n    console.log(foo); // foo 函数提升，打印 foo 函数\n    function foo() {};\n}\n\n\nfoo2(); // 报错 foo2 is not a function\n\nif (true) { // 不管是 true 还是 false，运行 foo2 时 foo2 还未赋值为函数\n    function foo2() {\n        console.log(1);\n    }\n}\n```","tags":["js"]},{"title":"php面向对象","url":"/yideng/2019/03/10/php-oop/","content":"\n**OOP目标：重用性、灵活性、扩展性。特点：封装、继承、多态**\n**对象特征：行为、状态、标识。**\n\n## 类的声明\n\n### 成员属性\n\n**格式 修饰符 $变量名 [=默认值]**\n\n``` php\npublic $var = 100; // 普通数值（整数、浮点数、布尔、字符串）\npublic $var = myConst; // 常量\npublic $var = self::classConstant; // 静态属性\npublic $var = array(1, 2); // 数组\n```\n\n### 成员方法\n\n**格式 修饰符 function 方法名() {}**\n\n### 实例化对象\n\n**$对象名称 = new 类名([arg])**\n\n### 属性访问\n\n``` php\n$对象名称->成员属性  // 获取\n$对象名称->成员属性 = 赋值 // 赋值\n$对象名称->成员方法()  // 调用\n```\n\n### $this\n\n**php 中的 this 指向实例。**\n``` php\nclass Car{\n    public $name;\n    public function logName() {\n        echo \"this name is {$this -> name}\";\n        return 'ok';\n    }\n}\n\n$BMW = new Car();\n$BMW -> name = 'BMW';\n$ret = $BMW -> logName();\necho('<br/>');\necho($ret);\n```\n\n### 构造方法\n\n**new 对象的时候调用**\n\n**[修饰符] function__constructor() {}**\n\n### 析构方法\n\n**对象被销毁或没有代码再执行的时候调用**\n\n**[修饰符] function__constructor() {}**\n\n``` php\nclass Car{\n    public function __construct($name) {\n        $this -> name = $name;\n    }\n\n    public function logName() {\n        echo \"this name is {$this -> name}\";\n        return 'ok';\n    }\n\n    public function __destruct() {\n        echo 'delete';\n    }\n}\n\n$BMW = new Car('BMW');\n$ret = $BMW -> logName();\necho('<br/>');\necho($ret);\necho('<br/>');\n\n// 打印 \n// this name is BMW\n// ok\n// delete\n```\n## 封装\n\n### 修饰符\n\n**public 公有。private 私有，只能在class里访问。protected 受保护，只能在class里访问，继承时候有行为。final 定义的方法属性不能被继承覆盖。**\n\n### 魔术方法\n\n**public 公有。private 私有，只能在class里访问。protected 受保护，只能在class里访问，继承时候子类可以访问。**\n\n**__set，设置private或者protected属性时触发。**\n\n**__get，获取private或者protected属性时触发。**\n\n**__isset，判断private或者protected属性存在时出发。**\n\n**__unset，删除private或者protected属性时触发。**\n\n``` php\nclass Car{\n    public function __construct($pb, $pv, $pt) {\n        $this -> pb = $pb;\n        $this -> pv = $pv;\n        $this -> pt = $pt;\n    }\n\n    public $pb;\n    private $pv;\n    protected $pt;\n\n    public function __set($key, $val) {\n        echo \"{$key} {$val}\";\n    }\n\n    public function __get($key) {\n        echo \"{$key}\";\n        return $this -> $key;\n    }\n    \n    public function __isset($key) {\n        echo \"{$key}\";\n        return false;\n    }\n\n    public function __unset($key) {\n        echo \"{$key}\";\n        return false;\n    }\n}\n\n$BMW = new Car('1', '2', '3');\n$BMW -> pb = '4';\n// 不打印\necho '<br/>';\n$BMW -> pv = '5';\n// 打印 pv 5\necho '<br/>';\n$BMW -> pt = '6';\n// 打印 pt 6\necho '<br/>';\n\necho '<br/>';\necho $BMW -> pb;\n// 打印 4\necho '<br/>';\necho $BMW -> pv;\n// 打印 pv2\necho '<br/>';\necho $BMW -> pt;\n// 打印 pt3\necho '<br/>';\n\necho '<br/>';\nvar_dump(isset($BMW -> pb));\n// 打印 bool(true) \necho '<br/>';\nvar_dump(isset($BMW -> pv));\n// 打印 pvbool(false) \necho '<br/>';\nvar_dump(isset($BMW -> pt));\n// 打印 ptbool(false) \necho '<br/>';\n\necho '<br/>';\nunset($BMW -> pb);\n// 打印 pb  unset的时候会触发公共属性的get？\necho $BMW -> pb;\n// 报错\necho '<br/>';\nunset($BMW -> pv);\necho $BMW -> pv;\n// pvpv2\necho '<br/>';\nunset($BMW -> pt);\necho $BMW -> pt;\n// ptpt3\necho '<br/>';\n```\n\n## 继承\n\n### 重写和重载\n\n**public 公有。private 私有，只能在class里访问。protected 受保护，只能在class里访问，继承时候子类可以访问。**\n\n**父类的非私有的方法和属性可以重载或者重写，重载时需要调用一次父级的方法。**\n\n``` php\nclass Car{\n    public $pb;\n    private $pv;\n    protected $pt;\n\n    public function __construct($pb, $pv, $pt) {\n        $this -> pb = $pb;\n        $this -> pv = $pv;\n        $this -> pt = $pt;\n    }\n\n    public function log() {\n        echo $this -> pb;\n        echo '<br/>';\n        echo $this -> pv;\n        echo '<br/>';\n        echo $this -> pt;\n    }\n}\n\nclass BMW extends Car{\n    public function __construct($pb, $pv, $pt) {\n        parent::__construct($pb, $pv, $pt);\n    }\n\n    public function log($val) {\n        echo \"reload {$val}\";\n        echo '<br/>';\n        parent::log();\n    }\n\n    public function logPv() {\n        echo $this -> pt;\n    }\n}\n\n$bmw = new BMW(1, 2, 3);\n$bmw -> logPv();\n// 打印3\n$bmw -> log(666);\n// 打印 eload 666\n// 1\n// 2\n// 3\n```\n\n## 抽象\n\n### 抽象方法和抽象类\n\n**类中的方法没有方法体（花括号），直接用分号结束，叫做抽象方法，使用 abstract 定义。**\n\n**包含这种方法的类必须是抽象类，使用 abstract 声明。**\n\n**抽象类不能实例化，必须定义一个类继承抽象类并覆盖实现父类的抽象方法。**\n\n``` php\nabstract class AbstractClass\n{\n // 强制要求子类定义这些方法\n    abstract protected function getValue();\n    abstract protected function prefixValue($prefix);\n\n    // 普通方法（非抽象方法）\n    public function printOut() {\n        print $this->getValue() . PHP_EOL;\n    }\n}\n\nclass ConcreteClass1 extends AbstractClass\n{\n    protected function getValue() {\n        return \"ConcreteClass1\";\n    }\n\n    public function prefixValue($prefix) {\n        return \"{$prefix}ConcreteClass1\";\n    }\n}\n\nclass ConcreteClass2 extends AbstractClass\n{\n    public function getValue() {\n        return \"ConcreteClass2\";\n    }\n\n    public function prefixValue($prefix) {\n        return \"{$prefix}ConcreteClass2\";\n    }\n}\n\n$class1 = new ConcreteClass1;\n$class1->printOut();\necho $class1->prefixValue('FOO_') . PHP_EOL;\n\n$class2 = new ConcreteClass2;\n$class2->printOut();\necho $class2->prefixValue('FOO_') . PHP_EOL;\n```\n\n### 接口\n\n**php 不能多继承，但是 php 有接口。接口指定了实现该接口的类必须实现的函数。使用 interface 定义，implements 继承。可以声明常量和抽象方法，变量不行。接口中的方法都是抽象的，不用 abstract 定义。接口不能实例化。**\n\n``` php\n// 声明一个'iTemplate'接口\ninterface iTemplate\n{\n    public function setVariable($name, $var);\n    public function getHtml($template);\n}\n\n\n// 实现接口\nclass Template implements iTemplate\n{\n    private $vars = array();\n  \n    public function setVariable($name, $var)\n    {\n        $this->vars[$name] = $var;\n    }\n  \n    public function getHtml($template)\n    {\n        foreach($this->vars as $name => $value) {\n            $template = str_replace('{' . $name . '}', $value, $template);\n        }\n \n        return $template;\n    }\n}\n```","tags":["OOP"]},{"title":"php笔记","url":"/yideng/2019/03/10/php/","content":"\n## 块级作用域\n``` php\nif (true) {\n    $a = 1;\n    echo $a;\n}\necho $a;\n// 打印 1\n\nif (false) {\n    $a = 1;\n}\necho $a;\n// 报错\n```\n\n## 检查是否声明\n``` php\nif (isset($a)) {\n    echo 'set a;';\n}\n\nif (!isset($b)) {\n    echo 'unset b;';\n}\n// 打印 set a;unset b;\n```\n\n## 全局变量\n``` php\n$a = 'out';\nfunction t() {\n    echo $a;\n}\nt();\n// 报错\n\n$a = 'out';\nfunction t() {\n    global $a;\n    echo $a;\n}\nt();\n// 打印 out\n```\n\n## 数组\n``` php\n$cars = array(\"Volvo\", \"BMW\");\necho json_encode($cars);\n// 打印 [\"Volvo\",\"BMW\"]\n$name = array(\"name\" => \"jqx\");\necho json_encode($name);\n// 打印 {\"name\":\"jqx\"}\n$cars_name = array(\"Volvo\", \"BMW\", \"name\" => \"jqx\");\necho json_encode($cars_name);\n// 打印 {\"0\":\"Volvo\",\"1\":\"BMW\",\"name\":\"jqx\"}\n```\n\n## session\n\n**php的session和js不同，php以浏览器为单位，js以当前页面为单位**\n\n``` php\nsession_start();\n// 存储 session 数据\nif(isset($_SESSION['views']))\n{\n    $_SESSION['views']=$_SESSION['views']+1;\n}\nelse\n{\n    $_SESSION['views']=1;\n}\n\n\n// 检索 session 数据\necho \"浏览量：\". $_SESSION['views'];\n```\n\n## 表单请求\n**$_GET, $_POST, $_REQUEST**\n\n**获取 application/json; 消息得使用 file_get_contents('php://input');**\n\n``` js\n// 前端测试代码\n(async() => {\nlet body = await fetch('/jqx/request.php', {\n    body: JSON.stringify({\n\t\t\tadmin: 'jqx',\n\t\t\tpsword: '123456'\n\t\t}), // must match 'Content-Type' header\n    headers: {\n      'content-type': 'application/json'\n    },\n    method: 'POST', // *GET, POST, PUT, DELETE, etc.\n  })\n\nlet json = await body.json();\nconsole.log(json);\n})()\n```\n\n## php链接数据库\n``` php\n$servername = \"localhost\";\n$username = \"username\";\n$password = \"password\";\n$dbname = \"test\";\n\n$conn = new mysqli($servername, $username, $password, $dbname);\n\nif ($conn->connect_error) {\n    die(\"连接失败: \" . $conn->connect_error);\n} \necho \"连接成功\";\n```\n\n## php操作数据库\n```php\n$sql = \"INSERT INTO user (username, email)\nVALUES ('jqx', '272670445@qq.com')\";\n \nif ($conn -> query($sql) === TRUE) {\n    echo \"新记录插入成功\";\n} else {\n    echo \"Error: \" . $sql . \"<br>\" . $conn->error;\n}\n \n$conn -> close();\n```\n\n## php PDO\n``` php\n$dbms='mysql';     //数据库类型\n$host='localhost'; //数据库主机名\n$dbName='test';    //使用的数据库\n$user='root';      //数据库连接用户名\n$pass='';          //对应的密码\n$dsn=\"$dbms:host=$host;dbname=$dbName\";\n\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象\n    echo \"连接成功<br/>\";\n\n    $dbh = null;\n} catch (PDOException $e) {\n    die (\"Error!: \" . $e->getMessage() . \"<br/>\");\n}\n//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT => true) 变成这样：\n$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n```\n\n## PDO 数据库操作\n``` php\n// 查询\nforeach ($dbh->query('SELECT * from user') as $row) {\n    $ret = json_encode($row);\n    echo(\"$ret</br>\"); //你可以用 echo($GLOBAL); 来看到这些值\n}\n\n// 执行语句\n$count = $dbh->exec(\"UPDATE user SET email = '272670445@163.com' WHERE username = 'jqx'\");\necho \"受影响行数{$count}\"\n```","tags":["php"]},{"title":"js和后台语言的差异","url":"/yideng/2019/03/08/js-OOP/","content":"\n## 强类型\n\n**强类型优势：**\n**1.  数据类型固定不变，减少了程序由于数据类型问题报错的概率，保证程序健壮性。**\n**2.  所有变量类型确定，增加了一定可读性。**\n\n## 变量\n\n### var 声明变量\n\n**使用 var 关键字声明变量，会导致变量的提升。在 let 出现之后，这个问题很好的解决了。**\n\n``` js\nconsole.log(a);\nvar a = 1;\n// 打印 undefined\n\nconsole.log(a);\nlet a = 1;\n// 报错 b is not defined\n```\n\n### function 声明\n\n**使用 function 关键字声明函数时，会导致函数提升，提升的方式与浏览器的版本密切相关。**\n\n``` js\nfunction test() {\n    console.log('out');\n}\n\n(function () {\n    if (false) {\n        function test() {\n            console.log('in');\n        }\n    }\n\n    test()\n})()\n\n// 老版本浏览器 打印 in\n// 新版本浏览器 报错 test is not a function\n```\n\n**在ES6的浏览器中，它们的行为实际上是这样的：**\n\n**1.   允许块级作用域中定义函数。**\n\n**2.   函数声明实际上将会类似于使用 var 声明的函数表达式，函数名将会提升至当前函数作用域顶。**\n\n**3.   同时函数声明也会保持在块级作用域中的提升行为。**\n\n**上述代码在现代浏览器中类似：**\n\n``` js\nvar test;\ntest = function () {\n    console.log('out');\n}\n\n(function () {\n    var test;\n    if (false) {\n        test = function () {\n            console.log('in');\n        }\n    }\n\n    test();\n})()\n```\n\n## this\n\n**一般后台语言中的 this 就指向当前class类，但js 中 this 是多变的，这已经是老生常谈了。js 中的 this 分了三种情况。**\n\n**1.   普通函数调用，this 指向window。**\n\n**2.   对象调用，this 指向调用方法的对象。**\n\n**3.   构造函数，this 指向返回的实例。**\n\n## 函数参数\n\n**js 中的函数在运行时，传入的参数与定义时的参数数量可以不同，在函数内可以通过 arguments 对象取得未定义的参数，这使 js 有时候变得方便，但是缺失了函数的重载（可以通过一些[技巧](../../06/js-skill/)实现函数重载）**\n\n## 数组\n\n**js 中的数组不是真的数组，他属于对象。当数组下标都是连续时，数组为快数组，而下标不连续时，数组就变成了 map。当操作只有出栈入栈时，js 数组的性能会不如 List。**\n\n**[从Chrome源码看JS Array的实现](https://zhuanlan.zhihu.com/p/26388217)**\n\n## 面向对象\n\n**在 es6 到来之前，网上流传了多个版本的使用 es3 实现类和继承，其中最为出名的就是基于原型的继承方式。**\n\n**在 es6 中引入 Class 关键字，这简直太棒了，避免了各个公司或插件实现的继承不同而造成阅读代码困难的问题，并且 Class 使用起来相对方便。**\n\n**但是 Class 暂时还没有私有变量的概念，不想其他的后端语言。**","tags":["js"]},{"title":"js 小技巧","url":"/yideng/2019/03/06/js-skill/","content":"\n### js 重载\n\n**众所周知，js 中没有重载概念，但可以利用代码来实现重载。**\n\n``` js\nfunction addMethod(obj, name, fn) {\n    let oldFn = obj[name];\n\n    obj[name] = function (...arg) {\n        arg.length === fn.length? fn(...arg): oldFn(...arg);\n    }\n}\n\nlet jqx = {};\naddMethod(jqx, 'say', () => {console.log(0)});\naddMethod(jqx, 'say', (a) => {console.log(1)});\naddMethod(jqx, 'say', (a, b) => {console.log(2)});\n\njqx.say();\njqx.say('a');\njqx.say('a', 'b');\n```\n\n**如果怕调用栈太深，也可以借助 map 对象把 arg.length 和 函数对应起来。**\n\n### 优化 switch\n\n**有些情况下，需同时判断多个条件，写 if-else 和 switch 会使函数看起来相当庞大，不妨试试 map。**\n\n``` js\nlet classical = new Map();\nclassical.set(20, '弱冠');\nclassical.set(30, '而立');\nclassical.set(40, '不惑');\nclassical.set(50, '知天命');\nclassical.set(60, '花甲子');\nclassical.set(70, '古来稀');\nclassical.set(80, '耄耋之年');\n\nfunction age2classical(age) {\n    return classical.get(age);\n}\n\nage2range(20); // 弱冠\nage2range(25); // undefined\nage2range(40); // 不惑\n```\n\n### 一行获取数组的交集、并集、差集\n\n``` js\nlet a = [1, 2, 3];\nlet b = [3, 4, 5];\n\na.filter(item => b.includes(item)); // 交集\n[...new Set([...a, ...b])]; // 并集\n[...new Set([...a, ...b])].filter(item => !(a.includes(item) && b.includes(item))); // 差集\n```","tags":["js"]},{"title":"jquery 技术内幕","url":"/yideng/2019/03/04/jquery-technology-insider/","content":"\n<script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"></script>\n\n**记录前端鼻祖 ———— jquery 的 js 技巧**\n\n### jquery 对象\n\n**在没有 es6 的 Class 之前，js 中都使用 function 以及他的 propotype 来实现面向对象。但是尽管如此，总有人在初始化实例时，忘记加上 new 关键字，这就会造成意外的全局污染。**\n\n``` js\nfunction Person(name) {\n    this.name = name;\n}\n\n// 正常使用\nvar man = new Person('老王');\nconsole.log(man.name); // 打印 老王\n\n// 忘记带 new\nvar man = Person('老王');\nconsole.log(window.name); // window 添加了一个变量 name\n```\n\n**这就会在你不知情的情况下，定义了一个全局变量。而 jquery 在生成新对象的时候，从来都没有带上 new 关键字，jquery 在创建对象时使用了一个技巧。**\n\n``` js\nfunction Person(name) {\n    this.name = name;\n}\n\nfunction createPerson(name) {\n    return new Person(name);\n}\n\nvar man = new createPerson('老王');\nvar woman = createPerson('小丽');\n\nconsole.log(man.name); // 打印 老王\nconsole.log(woman.name); // 打印 小丽\nconsole.log(man.prototype === woman.prototype); // 打印 true\n```\n\n**使用 new 关键字后，如果函数 return 了一个对象，返回对象，若返回的不是对象则创建一个新对象返回。**\n\n**在 createPerson 函数返回了一个 new Preson，使得即使不使用 new 关键字也可以创建对象实例，既保证创建对象时的安全，也方便调用。**\n\n**源码中的代码：**\n\n![jquery_init](../../../../img/jquery_technology_insider/jquery_init.png)\n\n### jquery 原型\n\n**在使用 jquery 的插件时，在 $.fn 上扩展方法，对象 $() 上就能访问刚刚挂载的方法。**\n\n``` js\n$.fn.log123 = function () {\n    console.log(123)\n}\n\n$().log123() // 打印 123\n```\n\n**再结合上面返回的 $.fn.init 实例，可见 $.fn 就是 $.fn.init.prototype。的确在源码中也做了这样的定义，使得返回的对象可以拿到原型上的方法。**\n\n![jquery_init_propotype](../../../../img/jquery_technology_insider/jquery_init_propotype.png)\n\n**再附上一张 jquery 非常绕的原型图：**\n\n![jquery_propotype](../../../../img/jquery_technology_insider/jquery_propotype.png)\n\n### 类型判断\n\n**在判断一个对象是 json 还是 array 的时候，公认的有效的方法是使用 Object.prototype.toString.call( Obj )。对于得到的字符串还要进行 slice 才能拿到对象真正的类型。**\n\n**在 jquery 中，建立了一个 map 来获取对象的类型。**\n\n``` js\nconst class2type = {};\n\n\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ).forEach(name => {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n})\n\n/*\n* 得到\n* {\n*   \"[object Boolean]\": \"boolean\",\n*   \"[object Number]\": \"number\",\n*   \"[object String]\": \"string\",\n*   \"[object Function]\": \"function\",\n*   \"[object Array]\": \"array\",\n*   \"[object Date]\": \"date\",\n*   \"[object RegExp]\": \"regexp\",\n*   \"[object Object]\": \"object\",\n*   \"[object Error]\": \"error\",\n*   \"[object Symbol]\": \"symbol\"\n* }\n*/  \n\nconst toString = class2type.toString;\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n```","tags":["jquery"]},{"title":"css 矩阵和 tramsform 之间换算","url":"/yideng/2019/03/03/css-matrix/","content":"\n**在学数学时，同学们总在一起打趣：学这么多的函数运算有什么用，以后买菜总不能先列一个函数，算出该付多少钱吧。可谁知，在科技高速发展的时代，打趣的话也快要“实现”了。**\n**在 css3 中，退出了新属性——— matrix(矩阵)，这不正是大一时候学的线性代数吗（好在大一的时候还不是很皮，都认真听讲了）**\n\n### 矩阵计算\n\n**css3 中的 matrix 用来代替多个 transfrom 属性或者一些 transfrom 无法实现的效果，就来看一看 matrix 是怎么实现变换的吧。**\n\n**首先来看一下矩阵的参数：**\n``` js\ntransform: matrix(a,b,c,d,e,f);\n```\n\n**这6个参数提供了一个 3 * 3 的矩阵，而经过这个矩阵能够计算出变换前的 x，y 值与变换后的 x，y 值的关系。反应式如下：**\n\n![matrix](../../../../img/css-matrix/matrix.gif)\n\n**其中 x，y 为变化前的坐标，ax+cy+e 为变换后的 x'，bx+dy+f 表示变换后的 y'。**\n**举个例子，如果我们有一个矩形有 A(0, 0) B(200, 0) C(0, 100) D(200, 100) 四个点组成，经过矩阵转换后，我们希望得到如下变换：**\n\n![transfrom](../../../../img/css-matrix/transfrom.png)\n\n**在 css 中，坐标轴的零点都是左上角，x 轴和 y 轴的方向也与数学中的坐标轴有所不同。也就是我们需要得到的矩阵坐标为 A'(300, 100) B'(300, 300) C'(400, 100) D'(400, 300)，那么就可以根据公式 ax+cy+e=x'，bx+dy+f=y' 算出 a,b,c,d,e,f 各为多少。**\n\n``` js\n// 将 A(0, 0) 和 A'(300, 100) 两点带入 ax+cy+e=x' bx+dy+f=y'\na * 0 + c * 0 + e = 300;\nb * 0 + d * 0 + f = 100;\n\ne = 300;\nf = 100;\n\n// 以此类推，将四个点全部带入计算得出 a,b,c,d,e,f 四个值\n// 此例中为 \ntransform: matrix(0, 1, 1, 0, 300, 100);\n```\n\n**最终矩阵变换的效果图如下**\n\n<iframe src=\"https://howgraceu.github.io/demo/matrix/\" style=\"margin-left: -2em; width: 100%; height: 225px;\"><iframe>\n\n### matrix 与 transfrom 各个属性的转换。\n\n**transfrom 的各个属性能够与 matrix 相互转换。**\n\n``` css\n/* matrix 默认值 */\ntransform: matrix(1, 0, 0, 1, 0, 0);\n\n/* translate */\ntransform: translate(x, y);\ntransform: matrix(0, 0, 0, 0, x, y);\n\n/* scale */\ntransform: scale(x, y);\ntransform: matrix(x, 0 * x, 0 * y, y, 0, 0);\n\n/* rotate */\nrotate: rotate(θ);\ntransform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0);\n```\n\n**张鑫旭大神的博客[理解CSS3 transform中的Matrix](https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/) 一文对此有详细的解释。**\n\n**但是需要注意的是，当 scale 和 rotate 一起使用的时候，两者的值需要相乘。**\n\n``` css\n/* scale 2 */\ntransform: scale(x, y);\nrotate: rotate(θ);\n\ntransform: matrix(cosθ * x, sinθ * x, -sinθ * y, cosθ * y, 0, 0);\n```\n\n### matrix 与 transfrom 转换函数。\n\n**根据 matrix 与 transfrom 之间的关系，可以提出一个函数来进行两者之间的转换（转换顺序为先 transfrom 再 rotate）。**\n\n``` js\nconst PI = Math.PI;\n\nfunction encodeMatrix({translateX = 0, translateY = 0, rotate=0, scaleX=1, scaleY=1} = {}) {\n    let rad = rotate * PI / 180;\n    let a = scaleX * Math.cos(rad);\n    let b = scaleX * Math.sin(rad);\n    let c = scaleY * -Math.sin(rad);\n    let d = scaleY * Math.cos(rad);\n    let e = translateX;\n    let f = translateY;\n\n    return [a,b,c,d,e,f]\n}\n\nfunction decodeMatrix([a = 1, b = 0, c = 0, d = 1, e = 0, f = 0] = []) {\n    let translateX = e;\n    let translateY = f;\n    let scaleX = Math.round(Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)));\n    let scaleY = Math.round(Math.sqrt(Math.pow(c, 2) + Math.pow(d, 2)));\n    let radC = Math.acos(a / scaleX);\n    let radS = Math.asin(b / scaleX);\n\n    let rad\n    if (b >= 0) {\n        rad = radC;\n    } else if (b < 0) {\n        rad = 2 * PI - radC;\n    }\n\n    let rotate = Math.round(rad * 180 / Math.PI);\n\n    return {translateX, translateY, rotate, scaleX, scaleY}\n}\n\nlet matrix = encodeMatrix({translateX: 30, translateY: 40, rotate: 45, scaleX: 2, scaleY: 3});\n//  [1.4142135623730951, 1.414213562373095, -2.1213203435596424, 2.121320343559643, 30, 40]\n\nlet transfrom = decodeMatrix([1.4142135623730951, 1.414213562373095, -2.1213203435596424, 2.121320343559643, 30, 40]);\n// {translateX: 30, translateY: 40, rotate: 45, scaleX: 2, scaleY: 3}\n```\n\n**上述函数在自己写的一个 [svg-editor](https://howgraceu.github.io/demo/svg/) 的例子中使用，但是在使用过程中发现如果缩放倍数不为整数时，可能会得到不精确的结果，导致最后结果偏差较大。**\n\n**最后附上一个用于转化 transfrom 和 matrix 的网页，[meyerweb-matrix](https://meyerweb.com/eric/tools/matrix/)**","tags":["matrix"]},{"title":"一灯笔记测试","url":"/yideng/2019/02/28/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["blogTest"]}]