[{"title":"array的长度大于10时，sort的行为","url":"/2018/10/25/arrSort/","content":"\n### 函数返回布尔时，排序不正常\n\n**同事说遇到了一个奇怪的bug，找我一起看，他的代码**\n\n``` js\nvar arr = [1,3,2,4,5,8,6,9,11,7,0];\n\narr.sort((a, b) => a > b);\n// [8, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11]\n```\n\n**wft！这有点颠覆我对js的认识啊，于是自己进行了测试，发现怎么测试结果都是正常的从小到大排序**\n\n**仔细查阅了mdn文档以及网上的资料发现，例子中的返回值都是以大于0，小于0和0来区别，并且数组长度大于10和小于等于10时，处理方法不一样。在大于10时，浏览器使用了一种快排的方法对数组进行排序，小于10时则是冒泡排序。**\n\n### 快排时会出现问题\n\n**于是进行进一步测试，当数组长度大于10时，果然数组的排序不尽如人意。似乎是快排的时候出了问题，于是翻了一下[github上V8项目中快排的代码](https://github.com/v8/v8/blob/master/src/js/array.js)，发现代码中的使用了 >= 来判断是否需要交换位置。所以返回false会使得if成立，而返回小于0则不会。**\n\n![V8快排](../../../../img/arrSort/V8QS.png)\n\n**综上，在sort的函数中，始终返回数值类型而不返回布尔类型就可以避免出现bug。**\n\n### 浏览器新版本支持度\n\n**顺便一提，测试时发现，在新版本的谷歌之中（70）和edge（17），不会处理返回布尔类型的情况。不管是冒泡还是快排。**\n``` js\nvar arr = [1,3,2,4,5,8,6,9];\n\narr.sort(function(a, b) {return a > b});\n// [1, 3, 2, 4, 5, 8, 6, 9]\n```\n\n### 快排算法\n\n**最后附上阮大大的对[快排](http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html)算法详细解释的文章**","tags":["v8"]},{"title":"node 循环引用","url":"/2018/09/14/node-cyclic/","content":"\n**近期在node开发的过程中，碰到require文件后，无法调用文件内定义的方法，翻阅资料怀疑是循环引用，于是自己进行了测试。**\n\n## 循环引用测试\n\n**a.js**\n``` js\nconsole.log('at a.js');\nvar b = require('./b');\n\nexports.test = \"i'm a\";\n\nsetImmediate(() => {\n    console.log(`get b.test ${b.test}`);\n})\n```\n\n**b.js**\n``` js\nconsole.log('at b.js');\nvar a = require('./a');\n\nmodule.exports = {\n    test: \"i'm b\"\n}\n\nsetImmediate(() => {\n    console.log(`get a.test ${a.test}`);\n})\n```\n\n**测试结果如下**\n``` js\nnode .\\a.js\n\nat a.js\nat b.js\nget a.test i'm a\nget b.test i'm b\n\nnode .\\b.js\n\nat b.js\nat a.js\nget b.test undefined\nget a.test i'm a\n```\n\n**运行b.js的时候，当运行到 require('./a') 的时候，去加载a.js的代码，而a.js里又 require('./b')，这里导致了循环引用。**\n\n**但是这里并不会进入死循环，原因是node在require的时候发现内存里已经存在这个模块的引用，则返回引用而不会重新去运行这个模块的代码。**\n\n**node .\\a.js的时候，require('./b')，而a.js停留在 var b = require('./b');，此时在b.js 得到的a模块的内容为a的module.exports {}。在运行完b.js之后，又在a的module.exports对象上加上属性，所以b中延迟打印出来的a的属性存在。**\n\n**而node .\\b.js的时候，require('./a')，b.js停留在var a = require('./a');，此时还没有运行module.exports = { test: \"i'm b\" }，得到b模块的内容为b的module.exports {}，运行完a之后，执行 module.exports = ... 代码，将module.exports指向了另一个对象，而缓存中b模块的内容则是之前引用的b的module.exports，所以b的test属性并没有加在b模块在内存中的对象上，所以之后再有require('./b')拿到的都是空对象 {}**\n\n## 避免循环引用产生的问题\n\n*   尽量不使用module.exports重置模块的引用。\n*   非要使用module.exports，module.exports应该放在js的开头，即其他逻辑之前。\n\n### 题外：在查node循环引用问题时，看到一个知名搜索引擎上较为靠前的博客有点问题。\n\n**以下为文中的测试代码**\n``` js\na.js\n\nconsole.log('a.js');\nvar b = require('./b');\nconsole.log('a+.js');\nconsole.log(b);\nexports={name:'a'};\nconsole.log('a++.js');\n\n\nb.js\n\nconsole.log('b.js');\nvar c = require('./a');\nconsole.log('b+.js');\nconsole.log(c);\nexports={name:'b'};\nconsole.log('b++.js');\n```\n\n**测试结果中，模块a和模块b都是 {}**\n**这个代码不管怎么改，打印出来的结果都是 {}，因为在node中 exports={name:'a'}; 无法用来暴露变量。原因如下**\n\n``` js\n(function (exports, require, module, __filenam, __dirname) {\n    ...文件中代码\n})\n```\n**代码来自《深入浅出nodejs》，上述代码的是在每一次用node运行js脚本的时候，都会运行上述函数来执行脚本中的代码，而脚本中使用的exports、module都只是这个函数中的一个局部变量。当你运行 exports={name:'a'}; 时，不过改变这个函数作用域中，局部变量的指向，而非改变 module.exports 所指向的对象中的属性。**","tags":["moudle"]},{"title":"axios跨域请求报错","url":"/2018/08/29/axios-CORS/","content":"\n**在一个开发web桌面应用的项目中，使用了axios向服务器发送请求，结果报了跨域请求的错误。页面代码大致如下：**\n\n``` js\n<script src=\"./node_modules/axios/dist/axios.js\"></script>\n<script>\n        axios.post('http://127.0.0.1:3000/getDate', {\n            a: 1\n        });\n</script>\n```\n\n![跨域报错](../../../../img/axios-CORS/1.png)\n\n**反复查看后台代码，明明是已经加上了跨域的头部Access-Control-Allow-Origin，可是还是请求失败。**\n**代码倒是看不出任何问题，于是猜想是axios内部框架做了什么鬼祟，使用原生的XHR对象进行调试。**\n\n![原生XHR跨域](../../../../img/axios-CORS/2.png)\n\n**果然请求到了，并且看到返回头里面带上了允许跨域头。仔细比对两次请求发现，axios发的请求的method竟是OPTIONS，这是什么，html难道不是只有GET，POST吗！？翻查[http mdn](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)**\n\n## xhr跨域请求\n\n**出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。以下三种情况下跨域请求的结果皆不相同。**\n\n### 简单请求\n\n**某些请求不会触发 CORS 预检请求。若请求满足所有下述条件，则该请求可视为“简单请求”：**\n\n*   **使用下列方法之一：**\n    *   GET\n    *   HEAD\n    *   POST\n*   **Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：**\n    *   Accept\n    *   Accept-Language\n    *   Content-Language\n    *   Content-Type （需要注意额外的限制）\n    *   DPR\n    *   Downlink\n    *   Save-Data\n    *   Viewport-Width\n    *   Width\n*   **Content-Type 的值仅限于下列三者之一：**\n    *   text/plain\n    *   multipart/form-data\n    *   application/x-www-form-urlencoded\n*   **请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。（文件上传对象）**\n*   **请求中没有使用 ReadableStream 对象。**\n\n### 预检请求\n**简单来说，请求不满足简单请求规范，则为预检请求。预检请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。**\n\n**从文章开头的例子中可以看出我们的OPTIONS是一个预检请求，应该是由axios发送跨域请求的时候进行了头部的设置导致。从OPSTIONS的抓包上看，请求头里面倒是有需要预检的首部字段。**\n\n```\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Content-Type \n\n// 服务器端应加上\nAccess-Control-Allow-Methods: POST //简单请求允许method，可不带\nAccess-Control-Allow-Headers: Content-Type\n```\n\n**看来是axios将请求头进行了设置导致跨域失败，进入axios源码查看，哪里进行了配置。进入源码查询发现axios在参数为json对象时，设置了content-type为application/json;charset=utf-8**\n\n![axios源码](../../../../img/axios-CORS/3.png)\n\n### 解决方案一：修改请求头\n\n**一种解决方法是axios设置默认头部**\n\n``` js\n<script src=\"./node_modules/axios/dist/axios.js\"></script>\n<script>\n        let config = {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            }\n        };\n\n        axios.post('http://127.0.0.1:3000/getDate', {\n            a: 1\n        }, config);\n</script>\n```\n\n### 解决方案二：服务端添加预检支持\n\n**这毕竟是一个跨域资源，是多人共享的资源，不能保证每个人请求头都属于简单请求，所以应该在服务器端对预检请求添加支持。**\n\n``` js\n// 这里以koa为例\nconst Koa = require('koa');\nconst Router = require('koa-router');\n\nconst app = new Koa();\nvar router = new Router();\n\nrouter\n  .get('/', (ctx, next) => {\n    ctx.body = 'Hello World!';\n  })\n  .post('/getDate', (ctx, next) => {\n    ctx.set('Access-Control-Allow-Origin', '*');\n    ctx.set('Access-Control-Allow-Headers', 'Content-Type');\n    ctx.response.type = 'json';\n    ctx.response.body = { data: 'Hello World' };\n  })\n\napp\n  .use(router.routes())\n  .listen(3000);\n```\n\n**加上响应头之后，理应能够自定义content-type的值，且成功跨域才对。可是跑最开始的跨域请求却出现404**\n\n![OPTIONS请求404](../../../../img/axios-CORS/4.png)\n\n**竟然是404，一顿推理，妄加猜测，应是服务器没有路径为/getDate，method 为 OPTIONS 的路由，在服务器端加上路由。**\n\n``` js\nrouter\n  .options('/getDate', (ctx, next) => {\n    ctx.set('Access-Control-Allow-Origin', '*');\n    ctx.set('Access-Control-Allow-Headers', 'Content-Type');\n    ctx.response.body = 'allow';\n  })\n```\n\n**加上后自定义头部的跨域请求也可以正常跨域了**\n\n![预检请求OPTOINS](../../../../img/axios-CORS/5.png)\n\n![预检请求POST](../../../../img/axios-CORS/6.png)\n\n**由上面2图可以看出，预检跨域请求，浏览器会发送2个请求到服务器端，一个是OPTIONS预检，一个是POST请求，产生2条抓包。**\n\n</br>\n### 题外：跨域资源共享标准 （有些不常用，mark一下）\n\n**跨域资源共享标准（ [cross-origin sharing standard](http://www.w3.org/TR/cors/) ）允许在下列场景中使用跨域 HTTP 请求：**\n\n*   **XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。**\n*   **Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。**\n*   **WebGL 贴图**\n*   **使用 drawImage 将 Images/video 画面绘制到 canvas**\n*   **样式表（使用 CSSOM）**\n*   **Scripts (未处理的异常)**","tags":["CORS"]},{"title":"hello world","url":"/2018/08/28/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["blogTest"]}]